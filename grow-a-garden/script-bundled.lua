-- 📦 BUNDLED ROBLOX SCRIPT
-- Generated by RobloxBundler
-- Date: 2025-09-27T04:09:00.865Z

-- 📚 EMBEDDED MODULES
local EmbeddedModules = {}

-- Module: UiModule
EmbeddedModules["https://raw.githubusercontent.com/alfin-efendy/ez-rbx-ui/refs/heads/main/ui.lua"] = function()
    local EzUI = {}
    local HttpService = game:GetService("HttpService")
    local EzUIFolder = "EzUI"
    local ConfigurationFolder = EzUIFolder .. "/Configurations"
    local ConfigurationExtension = ".json"
    EzUI.Flags = {}
    EzUI.Components = {}
    EzUI.Configuration = {
    	Enabled = false,
    	FileName = "DefaultConfig",
    	FolderName = "EzUI",
    	AutoSave = true,
    	AutoLoad = true
    }
    local function registerComponent(flag, componentAPI)
    	if flag and componentAPI then
    		if not EzUI.Components[flag] then
    			EzUI.Components[flag] = {}
    		end
    		table.insert(EzUI.Components[flag], componentAPI)
    	end
    end
    local function updateComponentsByFlag(flag, value)
    	if EzUI.Components[flag] then
    		for _, componentAPI in ipairs(EzUI.Components[flag]) do
    			if componentAPI.Set then
    				componentAPI.Set(value)
    			elseif componentAPI.SetValue then
    				componentAPI.SetValue(value)
    			elseif componentAPI.SetText then
    				componentAPI.SetText(value)
    			elseif componentAPI.SetSelected then
    				componentAPI.SetSelected(value)
    			end
    		end
    	end
    end
    local function saveConfiguration(fileName)
    	if not fileName then return false end
    	local flagsToSave = {}
    	local hasData = false
    	for key, value in pairs(EzUI.Flags) do
    		flagsToSave[key] = value
    		hasData = true
    	end
    	if not hasData then
    		print("EzUI: No configuration data to save")
    		return false
    	end
    	local dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
    	local dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
    	if writefile then
    		if not isfolder then
    			warn("EzUI: Configuration saving requires isfolder function")
    			return false
    		end
    		if not isfolder(dynamicFolderName) then
    			makefolder(dynamicFolderName)
    		end
    		if not isfolder(dynamicConfigurationFolder) then
    			makefolder(dynamicConfigurationFolder)
    		end
    		local filePath = dynamicConfigurationFolder .. "/" .. fileName .. ConfigurationExtension
    		local success, result = pcall(function()
    			writefile(filePath, HttpService:JSONEncode(flagsToSave))
    		end)
    		if success then
    			print("EzUI: Configuration saved to " .. filePath)
    			return true
    		else
    			warn("EzUI: Failed to save configuration: " .. tostring(result))
    			return false
    		end
    	else
    		warn("EzUI: Configuration saving requires writefile function")
    		return false
    	end
    end
    local function loadConfiguration(fileName)
    	if not fileName or not readfile or not isfile then 
    		warn("EzUI: Configuration loading requires readfile and isfile functions")
    		return false 
    	end
    	local dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
    	local dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
    	local filePath = dynamicConfigurationFolder .. "/" .. fileName .. ConfigurationExtension
    	if not isfile(filePath) then
    		print("EzUI: No configuration file found at " .. filePath)
    		return false
    	end
    	local success, configData = pcall(function()
    		return HttpService:JSONDecode(readfile(filePath))
    	end)
    	if not success then
    		warn("EzUI: Failed to load configuration file: " .. tostring(configData))
    		return false
    	end
    	local applied = 0
    	for flagName, flagValue in pairs(configData) do
    		EzUI.Flags[flagName] = flagValue
    		updateComponentsByFlag(flagName, flagValue)
    		applied = applied + 1
    	end
    	print("EzUI: Configuration loaded from " .. filePath .. " (" .. applied .. " settings applied)")
    	return true
    end
    function EzUI.NewConfig(configName)
    	if not configName or type(configName) ~= "string" then
    		warn("EzUI.NewConfig: configName must be a string")
    		return nil
    	end
    	local customFlags = {}
    	local function saveCustomConfig()
    		local dataToSave = {}
    		local hasData = false
    		for key, value in pairs(customFlags) do
    			if value ~= nil then
    				dataToSave[key] = value
    				hasData = true
    			end
    		end
    		if not hasData then
    			print("EzUI.CustomConfig: No valid data to save for " .. configName)
    			return false
    		end
    		if not writefile or not isfolder or not makefolder then
    			warn("EzUI.CustomConfig: File operations not available")
    			return false
    		end
    		local dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
    		local dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
    		if not isfolder(dynamicFolderName) then
    			makefolder(dynamicFolderName)
    		end
    		if not isfolder(dynamicConfigurationFolder) then
    			makefolder(dynamicConfigurationFolder)
    		end
    		local filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
    		local success, result = pcall(function()
    			writefile(filePath, HttpService:JSONEncode(dataToSave))
    		end)
    		if success then
    			local savedCount = 0
    			for _ in pairs(dataToSave) do
    				savedCount = savedCount + 1
    			end
    			print("EzUI.CustomConfig: " .. configName .. " saved to " .. filePath .. " (" .. savedCount .. " keys)")
    			return true
    		else
    			warn("EzUI.CustomConfig: Failed to save " .. configName .. ": " .. tostring(result))
    			return false
    		end
    	end
    	local function loadCustomConfig()
    		if not readfile or not isfile then
    			warn("EzUI.CustomConfig: File operations not available")
    			return false
    		end
    		local dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
    		local dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
    		local filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
    		if not isfile(filePath) then
    			print("EzUI.CustomConfig: No file found for " .. configName .. " at " .. filePath)
    			return false
    		end
    		local success, configData = pcall(function()
    			return HttpService:JSONDecode(readfile(filePath))
    		end)
    		if not success then
    			warn("EzUI.CustomConfig: Failed to load " .. configName .. ": " .. tostring(configData))
    			return false
    		end
    		local applied = 0
    		for flagName, flagValue in pairs(configData) do
    			customFlags[flagName] = flagValue
    			applied = applied + 1
    		end
    		print("EzUI.CustomConfig: " .. configName .. " loaded (" .. applied .. " settings applied)")
    		return true
    	end
    	local function autoLoadCustomConfig()
    		if loadCustomConfig() then
    			for flagName, flagValue in pairs(customFlags) do
    				EzUI.Flags[flagName] = flagValue
    				updateComponentsByFlag(flagName, flagValue)
    			end
    		end
    	end
    	task.defer(function()
    		autoLoadCustomConfig()
    	end)
    	return {
    		GetValue = function(key)
    			if not key then
    				warn("EzUI.CustomConfig.GetValue: key parameter is required")
    				return nil
    			end
    			return customFlags[key]
    		end,
    		SetValue = function(key, value)
    			if not key then
    				warn("EzUI.CustomConfig.SetValue: key parameter is required")
    				return false
    			end
    			customFlags[key] = value
    			saveCustomConfig()
    			return true
    		end,
    		GetAll = function()
    			local result = {}
    			for key, value in pairs(customFlags) do
    				if value ~= nil then
    					result[key] = value
    				end
    			end
    			return result
    		end,
    		GetAllKeys = function()
    			local keys = {}
    			for key, value in pairs(customFlags) do
    				if value ~= nil then
    					table.insert(keys, key)
    				end
    			end
    			return keys
    		end,
    		DeleteKey = function(key)
    			if not key then
    				warn("EzUI.CustomConfig.DeleteKey: key parameter is required")
    				return false
    			end
    			if customFlags[key] ~= nil then
    				customFlags[key] = nil
    				saveCustomConfig()
    				return true
    			else
    				warn("EzUI.CustomConfig.DeleteKey: key '" .. key .. "' not found")
    				return false
    			end
    		end
    	}
    end
    function EzUI.CreateWindow(config)
    	local windowOpacity = config.Opacity or 1.0
    	windowOpacity = math.max(0.1, math.min(1.0, windowOpacity))
    	local autoShow = config.AutoShow
    	if autoShow == nil then
    		autoShow = true 
    	end
    	local configSaving = config.ConfigurationSaving or {}
    	local configEnabled = configSaving.Enabled or false
    	local configFileName = configSaving.FileName or config.Name or "DefaultConfig"
    	local configFolderName = configSaving.FolderName or "EzUI"
    	local configAutoSave = configSaving.AutoSave
    	if configAutoSave == nil then
    		configAutoSave = true 
    	end
    	local configAutoLoad = configSaving.AutoLoad
    	if configAutoLoad == nil then
    		configAutoLoad = true 
    	end
    	EzUI.Configuration.Enabled = configEnabled
    	EzUI.Configuration.FileName = configFileName
    	EzUI.Configuration.FolderName = configFolderName
    	EzUI.Configuration.AutoSave = configAutoSave
    	EzUI.Configuration.AutoLoad = configAutoLoad
    	local function getViewportSize()
    		local camera = workspace.CurrentCamera
    		if not camera then
    			camera = workspace:WaitForChild("CurrentCamera", 5)
    		end
    		local viewportSize = camera.ViewportSize
    		if viewportSize.X <= 1 or viewportSize.Y <= 1 then
    			viewportSize = Vector2.new(1366, 768)
    			warn("EzUI: Using fallback viewport size:", viewportSize)
    		end
    		return viewportSize
    	end
    	local function calculateDynamicSize()
    		local viewportSize = getViewportSize()
    		local baseWidth = config.Width or (viewportSize.X * 0.7) 
    		local baseHeight = config.Height or (viewportSize.Y * 0.4) 
    		local scaleMultiplier = 1
    		if viewportSize.X >= 1920 then 
    			scaleMultiplier = 1.2
    		elseif viewportSize.X >= 1366 then 
    			scaleMultiplier = 1.0
    		elseif viewportSize.X >= 1024 then 
    			scaleMultiplier = 0.9
    		else 
    			scaleMultiplier = 0.8
    		end
    		local finalWidth = math.max(300, math.min(viewportSize.X * 0.8, baseWidth * scaleMultiplier))
    		local finalHeight = math.max(200, math.min(viewportSize.Y * 0.8, baseHeight * scaleMultiplier))
    		return finalWidth, finalHeight
    	end
    	local windowWidth, windowHeight = calculateDynamicSize()
    	local screenGui = Instance.new("ScreenGui")
    	screenGui.Name = config.Name or "MyWindow"
    	screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    	local frame = Instance.new("Frame")
    	frame.Size = UDim2.new(0, windowWidth, 0, windowHeight)
    	frame.Position = UDim2.new(0.5, -windowWidth / 2, 0.5, -windowHeight / 2)
    	frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    	frame.BackgroundTransparency = 1 - windowOpacity 
    	frame.BorderSizePixel = 0
    	frame.Active = true
    	frame.ClipsDescendants = true 
    	frame.ZIndex = 1 
    	frame.Visible = autoShow 
    	frame.Parent = screenGui
    	local scrollFrame = Instance.new("ScrollingFrame")
    	scrollFrame.Size = UDim2.new(1, -100, 1, -30) 
    	scrollFrame.Position = UDim2.new(0, 100, 0, 30) 
    	scrollFrame.BackgroundTransparency = 1
    	scrollFrame.BorderSizePixel = 0
    	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    	scrollFrame.ScrollBarThickness = 8
    	scrollFrame.ClipsDescendants = false 
    	scrollFrame.ZIndex = 2 
    	scrollFrame.Parent = frame
    	local tabPanel = Instance.new("Frame")
    	tabPanel.Size = UDim2.new(0, 100, 1, -30)
    	tabPanel.Position = UDim2.new(0, 0, 0, 30)
    	tabPanel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    	tabPanel.BackgroundTransparency = 1 - windowOpacity 
    	tabPanel.BorderSizePixel = 0
    	tabPanel.ClipsDescendants = true
    	tabPanel.ZIndex = 2 
    	tabPanel.Parent = frame
    	local tabScrollFrame = Instance.new("ScrollingFrame")
    	tabScrollFrame.Size = UDim2.new(1, 0, 1, 0)
    	tabScrollFrame.Position = UDim2.new(0, 0, 0, 0)
    	tabScrollFrame.BackgroundTransparency = 1
    	tabScrollFrame.BorderSizePixel = 0
    	tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    	tabScrollFrame.ScrollBarThickness = 6
    	tabScrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    	tabScrollFrame.ScrollingDirection = Enum.ScrollingDirection.Y
    	tabScrollFrame.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
    	tabScrollFrame.ZIndex = 3 
    	tabScrollFrame.Parent = tabPanel
    	local tabButtonLayout = Instance.new("UIListLayout")
    	tabButtonLayout.SortOrder = Enum.SortOrder.LayoutOrder
    	tabButtonLayout.Padding = UDim.new(0, 4)
    	tabButtonLayout.Parent = tabScrollFrame
    	tabButtonLayout.Changed:Connect(function(property)
    		if property == "AbsoluteContentSize" then
    			tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, tabButtonLayout.AbsoluteContentSize.Y + 8)
    		end
    	end)
    	local tabContents = {}
    	local activeTab = nil
    	local activeTabName = nil
    	local resizeHandle = Instance.new("ImageButton")
    	resizeHandle.Size = UDim2.new(0, 16, 0, 16)
    	resizeHandle.Position = UDim2.new(1, -16, 1, -16)
    	resizeHandle.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    	resizeHandle.BorderSizePixel = 0
    	resizeHandle.Image = "rbxassetid://16898613613"
    	resizeHandle.ImageRectOffset = Vector2.new(820,196)
    	resizeHandle.ImageRectSize = Vector2.new(48, 48) 
    	resizeHandle.ZIndex = 27 
    	resizeHandle.Parent = frame
    	local resizeDragging = false
    	local resizeStartPos, resizeStartSize, resizeInput
    	local UserInputService = game:GetService("UserInputService")
    	resizeHandle.InputBegan:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
    			resizeDragging = true
    			resizeStartPos = input.Position
    			resizeStartSize = frame.Size
    			resizeInput = input
    			input.Changed:Connect(function()
    				if input.UserInputState == Enum.UserInputState.End then
    					resizeDragging = false
    				end
    			end)
    		end
    	end)
    	resizeHandle.InputChanged:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
    			resizeInput = input
    		end
    	end)
    	UserInputService.InputChanged:Connect(function(input)
    		if input == resizeInput and resizeDragging then
    			local delta = input.Position - resizeStartPos
    			local currentViewport = getViewportSize()
    			local minWidth = math.max(250, currentViewport.X * 0.15) 
    			local minHeight = math.max(150, currentViewport.Y * 0.2) 
    			local maxWidth = currentViewport.X * 0.9 
    			local maxHeight = currentViewport.Y * 0.9 
    			local newWidth = math.max(minWidth, math.min(maxWidth, resizeStartSize.X.Offset + delta.X))
    			local newHeight = math.max(minHeight, math.min(maxHeight, resizeStartSize.Y.Offset + delta.Y))
    			frame.Size = UDim2.new(0, newWidth, 0, newHeight)
    			frame.Position = UDim2.new(0.5, -newWidth / 2, 0.5, -newHeight / 2)
    			scrollFrame.Size = UDim2.new(1, -100, 1, -30)
    			resizeHandle.Position = UDim2.new(1, -16, 1, -16)
    		end
    	end)
    	local header = Instance.new("Frame")
    	header.Size = UDim2.new(1, 0, 0, 30)
    	header.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    	header.BackgroundTransparency = 1 - windowOpacity 
    	header.BorderSizePixel = 0
    	header.ZIndex = 25 
    	header.Parent = frame
    	local title = Instance.new("TextLabel")
    	title.Size = UDim2.new(1, -100, 1, 0) 
    	title.Position = UDim2.new(0, 10, 0, 0)
    	title.BackgroundTransparency = 1
    	title.Text = config.Name or "My Window"
    	title.TextColor3 = Color3.fromRGB(255, 255, 255)
    	title.TextXAlignment = Enum.TextXAlignment.Left
    	title.Font = Enum.Font.SourceSansBold
    	title.TextSize = 16
    	title.ZIndex = 26 
    	title.Parent = header
    	local minimizeBtn = Instance.new("TextButton")
    	minimizeBtn.Size = UDim2.new(0, 30, 0, 30)
    	minimizeBtn.Position = UDim2.new(1, -60, 0, 0) 
    	minimizeBtn.BackgroundColor3 = Color3.fromRGB(200, 170, 0)
    	minimizeBtn.Text = "-"
    	minimizeBtn.ZIndex = 26 
    	minimizeBtn.Parent = header
    	local closeBtn = Instance.new("TextButton")
    	closeBtn.Size = UDim2.new(0, 30, 0, 30)
    	closeBtn.Position = UDim2.new(1, -30, 0, 0) 
    	closeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    	closeBtn.Text = "X"
    	closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    	closeBtn.Font = Enum.Font.SourceSansBold
    	closeBtn.TextSize = 18
    	closeBtn.ZIndex = 26 
    	closeBtn.Parent = header
    	closeBtn.MouseEnter:Connect(function()
    		closeBtn.BackgroundColor3 = Color3.fromRGB(255, 70, 70)
    	end)
    	closeBtn.MouseLeave:Connect(function()
    		closeBtn.BackgroundColor3 = Color3.fromRGB(200, 50, 50)
    	end)
    	local floatBtn = Instance.new("TextButton")
    	floatBtn.Size = UDim2.new(0, 120, 0, 35)
    	floatBtn.Position = UDim2.new(0, 10, 0, 45) 
    	floatBtn.BackgroundColor3 = Color3.fromRGB(100, 150, 250)
    	floatBtn.Text = "Open "..(config.Name or "UI")
    	floatBtn.Visible = not autoShow 
    	floatBtn.ZIndex = 30 
    	floatBtn.Parent = screenGui
    	local UserInputService = game:GetService("UserInputService")
    	local dragging, dragInput, dragStart, startPos
    	local currentTarget
    	local function updateDrag(input)
    		if currentTarget then
    			local delta = input.Position - dragStart
    			currentTarget.Position = UDim2.new(
    				startPos.X.Scale,
    				startPos.X.Offset + delta.X,
    				startPos.Y.Scale,
    				startPos.Y.Offset + delta.Y
    			)
    		end
    	end
    	header.InputBegan:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
    			dragging = true
    			dragStart = input.Position
    			startPos = frame.Position
    			currentTarget = frame
    			input.Changed:Connect(function()
    				if input.UserInputState == Enum.UserInputState.End then
    					dragging = false
    					currentTarget = nil
    				end
    			end)
    		end
    	end)
    	header.InputChanged:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
    			dragInput = input
    		end
    	end)
    	floatBtn.InputBegan:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
    			dragging = true
    			dragStart = input.Position
    			startPos = floatBtn.Position
    			currentTarget = floatBtn
    			input.Changed:Connect(function()
    				if input.UserInputState == Enum.UserInputState.End then
    					dragging = false
    					currentTarget = nil
    				end
    			end)
    		end
    	end)
    	floatBtn.InputChanged:Connect(function(input)
    		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
    			dragInput = input
    		end
    	end)
    	UserInputService.InputChanged:Connect(function(input)
    		if input == dragInput and dragging then
    			updateDrag(input)
    		end
    	end)
    	minimizeBtn.MouseButton1Click:Connect(function()
    		frame.Visible = false
    		floatBtn.Visible = true
    	end)
    	floatBtn.MouseButton1Click:Connect(function()
    		frame.Visible = true
    		floatBtn.Visible = false
    	end)
    	local api = {}
    	local currentY = 10 
    	local currentTabContent = nil
    	function api:UpdateWindowSize()
    		if currentTabContent then
    			scrollFrame.CanvasSize = UDim2.new(0, 0, 0, currentY + 10)
    		end
    	end
    	function api:AddTab(config)
    		local tabName, tabIcon, tabVisible, tabCallback
    		if type(config) == "string" then
    			tabName = config
    			tabIcon = nil
    			tabVisible = true
    			tabCallback = nil
    		else
    			tabName = config.Name or config.Title or "New Tab"
    			tabIcon = config.Icon or nil
    			tabVisible = config.Visible ~= nil and config.Visible or true
    			tabCallback = config.Callback or nil
    		end
    		local tabBtn = Instance.new("TextButton")
    		tabBtn.Size = UDim2.new(1, -6, 0, 32) 
    		tabBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    		tabBtn.Text = "" 
    		tabBtn.BorderSizePixel = 0
    		tabBtn.ZIndex = 4 
    		tabBtn.Visible = tabVisible
    		tabBtn.Parent = tabScrollFrame
    		local iconLabel = Instance.new("TextLabel")
    		iconLabel.Size = UDim2.new(0, 30, 1, 0)
    		iconLabel.Position = UDim2.new(0, 5, 0, 0)
    		iconLabel.BackgroundTransparency = 1
    		iconLabel.Text = tabIcon or ""
    		iconLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    		iconLabel.Font = Enum.Font.SourceSansBold
    		iconLabel.TextSize = 15
    		iconLabel.TextXAlignment = Enum.TextXAlignment.Left
    		iconLabel.ZIndex = 5
    		iconLabel.Parent = tabBtn
    		local titleLabel = Instance.new("TextLabel")
    		titleLabel.BackgroundTransparency = 1
    		titleLabel.Text = tabName
    		titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    		titleLabel.Font = Enum.Font.SourceSansBold
    		titleLabel.TextSize = 15
    		titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
    		titleLabel.ZIndex = 5
    		titleLabel.Parent = tabBtn
    		local function updateTitleAlignment()
    			if tabIcon and tabIcon ~= "" then
    				titleLabel.Size = UDim2.new(1, -40, 1, 0) 
    				titleLabel.Position = UDim2.new(0, 35, 0, 0)
    				titleLabel.TextXAlignment = Enum.TextXAlignment.Right
    				iconLabel.Visible = true
    			else
    				titleLabel.Size = UDim2.new(1, -10, 1, 0) 
    				titleLabel.Position = UDim2.new(0, 5, 0, 0)
    				titleLabel.TextXAlignment = Enum.TextXAlignment.Left
    				iconLabel.Visible = false
    			end
    		end
    		updateTitleAlignment()
    		local tabContent = Instance.new("Frame")
    		tabContent.Size = UDim2.new(1, 0, 1, 0)
    		tabContent.Position = UDim2.new(0, 0, 0, 0)
    		tabContent.BackgroundTransparency = 1
    		tabContent.Visible = false
    		tabContent.ClipsDescendants = false 
    		tabContent.ZIndex = 2 
    		tabContent.Parent = scrollFrame
    		tabContents[tabName] = tabContent
    		local tabCurrentY = 10
    		local function createSelectBox(config, parentContainer, currentY, updateSizeFunction, animateFunction, isExpanded, isForAccordion)
    			local rawOptions = config.Options or {"Option 1", "Option 2", "Option 3"}
    			local placeholder = config.Placeholder or "Select option..."
    			local multiSelect = config.MultiSelect or false
    			local callback = config.Callback or function() end
    			local onDropdownOpen = config.OnDropdownOpen or function() end
    			local onInit = config.OnInit or function() end
    			local flag = config.Flag
    			local options = {}
    			for i, option in ipairs(rawOptions) do
    				if type(option) == "string" then
    					table.insert(options, {text = option, value = option})
    				elseif type(option) == "table" and option.text and option.value then
    					table.insert(options, {text = option.text, value = option.value})
    				else
    					warn("SelectBox: Invalid option format at index " .. i .. ". Expected string or {text, value} object.")
    				end
    			end
    			local selectedValues = {}
    			local function ensureArrayType()
    				if type(selectedValues) ~= "table" then
    					selectedValues = selectedValues and {selectedValues} or {}
    				end
    			end
    			if flag and EzUI.Flags[flag] ~= nil then
    				local flagValue = EzUI.Flags[flag]
    				if multiSelect then
    					if type(flagValue) == "table" then
    						selectedValues = flagValue
    					else
    						selectedValues = flagValue ~= "" and {flagValue} or {} 
    					end
    				else
    					if type(flagValue) == "table" then
    						selectedValues = {flagValue[1]} 
    					else
    						selectedValues = flagValue ~= "" and {flagValue} or {} 
    					end
    				end
    			else
    				print("SelectBox Debug - No flag or flag is nil:", flag, EzUI.Flags[flag])
    			end
    			local isOpen = false
    			local preventAutoClose = false 
    			local selectContainer = Instance.new("Frame")
    			if isForAccordion then
    				selectContainer.Size = UDim2.new(1, 0, 0, 25) 
    				selectContainer.Position = UDim2.new(0, 0, 0, currentY)
    			else
    				selectContainer.Size = UDim2.new(1, -20, 0, 25) 
    				selectContainer.Position = UDim2.new(0, 10, 0, currentY)
    				selectContainer:SetAttribute("ComponentStartY", currentY)
    			end
    			selectContainer.BackgroundTransparency = 1
    			selectContainer.ClipsDescendants = false 
    			selectContainer.ZIndex = isForAccordion and 6 or 3 
    			selectContainer.Parent = parentContainer
    			local selectButton = Instance.new("TextButton")
    			selectButton.Size = UDim2.new(1, -25, 1, 0) 
    			selectButton.Position = UDim2.new(0, 0, 0, 0)
    			selectButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    			selectButton.BorderColor3 = Color3.fromRGB(180, 180, 180)
    			selectButton.BorderSizePixel = 2
    			selectButton.Text = "  " .. placeholder
    			selectButton.TextColor3 = Color3.fromRGB(200, 200, 200)
    			selectButton.TextXAlignment = Enum.TextXAlignment.Left
    			selectButton.Font = Enum.Font.SourceSans
    			selectButton.TextSize = isForAccordion and 12 or 14
    			selectButton.ZIndex = isForAccordion and 7 or 4
    			selectButton.Parent = selectContainer
    			local arrow = Instance.new("TextButton")
    			arrow.Size = UDim2.new(0, 25, 1, 0)
    			arrow.Position = UDim2.new(1, -25, 0, 0)
    			arrow.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    			arrow.BorderColor3 = Color3.fromRGB(180, 180, 180)
    			arrow.BorderSizePixel = 2
    			arrow.Text = "▼"
    			arrow.TextColor3 = Color3.fromRGB(200, 200, 200)
    			arrow.TextXAlignment = Enum.TextXAlignment.Center
    			arrow.Font = Enum.Font.SourceSans
    			arrow.TextSize = 10
    			arrow.ZIndex = isForAccordion and 7 or 4
    			arrow.Parent = selectContainer
    			local dropdownHeight = isForAccordion and math.min(#options * 25 + 30, 150) or math.min(#options * 30 + 30, 200)
    			local dropdownFrame = Instance.new("ScrollingFrame")
    			dropdownFrame.Size = UDim2.new(1, 0, 0, dropdownHeight)
    			dropdownFrame.Position = UDim2.new(0, 0, 1, 3)
    			dropdownFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    			dropdownFrame.BorderColor3 = Color3.fromRGB(150, 150, 150)
    			dropdownFrame.BorderSizePixel = 2
    			dropdownFrame.Visible = false
    			dropdownFrame.CanvasSize = UDim2.new(0, 0, 0, isForAccordion and (#options * 25 + 30) or (#options * 30 + 30))
    			dropdownFrame.ScrollBarThickness = 6
    			dropdownFrame.ScrollBarImageColor3 = Color3.fromRGB(120, 120, 120)
    			dropdownFrame.ZIndex = 25 
    			dropdownFrame.ClipsDescendants = true
    			dropdownFrame.Active = true
    			dropdownFrame.Parent = screenGui 
    			local searchBox = Instance.new("TextBox")
    			searchBox.Size = UDim2.new(1, -10, 0, 20)
    			searchBox.Position = UDim2.new(0, 5, 0, 5)
    			searchBox.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    			searchBox.BorderColor3 = Color3.fromRGB(100, 100, 100)
    			searchBox.BorderSizePixel = 1
    			searchBox.Text = ""
    			searchBox.PlaceholderText = "Search options..."
    			searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    			searchBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
    			searchBox.Font = Enum.Font.Gotham
    			searchBox.TextSize = 10
    			searchBox.ZIndex = 26 
    			searchBox.ClearTextOnFocus = false
    			searchBox.Parent = dropdownFrame
    			local optionsContainer = Instance.new("Frame")
    			optionsContainer.Size = UDim2.new(1, 0, 1, -30)
    			optionsContainer.Position = UDim2.new(0, 0, 0, 30)
    			optionsContainer.BackgroundTransparency = 1
    			optionsContainer.ZIndex = 26 
    			optionsContainer.Parent = dropdownFrame
    			local listLayout = Instance.new("UIListLayout")
    			listLayout.SortOrder = Enum.SortOrder.LayoutOrder
    			listLayout.Parent = optionsContainer
    			local function updateDisplayText()
    				if type(selectedValues) ~= "table" then
    					selectedValues = {selectedValues}
    				end
    				if #selectedValues == 0 then
    					selectButton.Text = "  " .. placeholder
    					selectButton.TextColor3 = Color3.fromRGB(200, 200, 200)
    				elseif multiSelect then
    					if #selectedValues == 1 then
    						local displayText = selectedValues[1]
    						for _, option in ipairs(options) do
    							if option.value == selectedValues[1] then
    								displayText = option.text
    								break
    							end
    						end
    						selectButton.Text = "  " .. (displayText or "Unknown")
    					elseif #selectedValues == 0 then
    						selectButton.Text = "  None"
    					else
    						selectButton.Text = "  " .. #selectedValues .. " items selected"
    					end
    					selectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    				else
    					local displayText = selectedValues[1]
    					for _, option in ipairs(options) do
    						if option.value == selectedValues[1] then
    							displayText = option.text
    							break
    						end
    					end
    					selectButton.Text = "  " .. (displayText or "Unknown")
    					selectButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    				end
    			end
    			local function calculateDropdownPosition()
    				local absolutePos = selectContainer.AbsolutePosition
    				local absoluteSize = selectContainer.AbsoluteSize
    				local viewportSize = getViewportSize()
    				local dropdownHeight = dropdownFrame.Size.Y.Offset
    				local dropdownWidth = absoluteSize.X
    				local spaceBelow = viewportSize.Y - (absolutePos.Y + absoluteSize.Y)
    				local spaceAbove = absolutePos.Y
    				local finalPosition
    				local finalX = absolutePos.X
    				local finalY = absolutePos.Y
    				if finalX + dropdownWidth > viewportSize.X then
    					finalX = viewportSize.X - dropdownWidth - 10
    				end
    				if finalX < 0 then
    					finalX = 10
    				end
    				if spaceBelow >= dropdownHeight + 10 then
    					finalY = absolutePos.Y + absoluteSize.Y + 3
    				elseif spaceAbove >= dropdownHeight + 10 then
    					finalY = absolutePos.Y - dropdownHeight - 3
    				else
    					if spaceBelow > spaceAbove then
    						finalY = absolutePos.Y + absoluteSize.Y + 3
    						local maxHeight = spaceBelow - 10
    						if dropdownHeight > maxHeight and maxHeight > 100 then
    							dropdownHeight = maxHeight
    							dropdownFrame.Size = UDim2.new(0, dropdownWidth, 0, dropdownHeight)
    						end
    					else
    						local maxHeight = spaceAbove - 10
    						if dropdownHeight > maxHeight and maxHeight > 100 then
    							dropdownHeight = maxHeight
    							dropdownFrame.Size = UDim2.new(0, dropdownWidth, 0, dropdownHeight)
    						end
    						finalY = absolutePos.Y - dropdownHeight - 3
    					end
    				end
    				if finalY + dropdownHeight > viewportSize.Y then
    					finalY = viewportSize.Y - dropdownHeight - 10
    				end
    				if finalY < 0 then
    					finalY = 10
    				end
    				finalPosition = UDim2.new(0, finalX, 0, finalY)
    				dropdownFrame.Position = finalPosition
    			end
    			local function refreshOptionsDisplay()
    				for _, child in pairs(optionsContainer:GetChildren()) do
    					if child:IsA("TextButton") then
    						child:Destroy()
    					end
    				end
    				for i, option in ipairs(options) do
    					local optionHeight = isForAccordion and 25 or 30
    					local optionButton = Instance.new("TextButton")
    					optionButton.Size = UDim2.new(1, -10, 0, optionHeight)
    					optionButton.Position = UDim2.new(0, 5, 0, (i-1) * optionHeight)
    					optionButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    					optionButton.BorderSizePixel = 0
    					optionButton.Text = "  " .. (option.text or "Unknown")
    					optionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    					optionButton.TextXAlignment = Enum.TextXAlignment.Left
    					optionButton.Font = Enum.Font.SourceSans
    					optionButton.TextSize = isForAccordion and 10 or 12
    					optionButton.ZIndex = 27
    					optionButton.Parent = optionsContainer
    					optionButton:SetAttribute("OptionIndex", i)
    					optionButton:SetAttribute("OptionValue", option.value)
    					optionButton:SetAttribute("OptionText", option.text)
    					local checkmark = Instance.new("TextLabel")
    					checkmark.Size = UDim2.new(0, 20, 1, 0)
    					checkmark.Position = UDim2.new(1, -20, 0, 0)
    					checkmark.BackgroundTransparency = 1
    					checkmark.Text = ""
    					checkmark.TextColor3 = Color3.fromRGB(100, 255, 100)
    					checkmark.TextXAlignment = Enum.TextXAlignment.Center
    					checkmark.Font = Enum.Font.SourceSansBold
    					checkmark.TextSize = 12
    					checkmark.ZIndex = 28
    					checkmark.Parent = optionButton
    					checkmark.Visible = multiSelect
    					local isSelected = false
    					if type(selectedValues) ~= "table" then
    						selectedValues = {selectedValues}
    					end
    					local optionValue = tostring(option.value)
    					for _, value in ipairs(selectedValues) do
    						if tostring(value) == optionValue then
    							isSelected = true
    							break
    						end
    					end
    					if isSelected then
    						checkmark.Text = "✓"
    						optionButton.BackgroundColor3 = Color3.fromRGB(70, 120, 70)
    					else
    						checkmark.Text = ""
    						optionButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    					end
    					optionButton.MouseButton1Click:Connect(function()
    						preventAutoClose = true 
    						if multiSelect then
    							local isCurrentlySelected = false
    							local indexToRemove = nil
    							if type(selectedValues) ~= "table" then
    								selectedValues = {selectedValues}
    							end
    							for j, value in ipairs(selectedValues) do
    								if value == option.value then
    									isCurrentlySelected = true
    									indexToRemove = j
    									break
    								end
    							end
    							if isCurrentlySelected then
    								table.remove(selectedValues, indexToRemove)
    								checkmark.Text = ""
    								optionButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    							else
    								table.insert(selectedValues, option.value)
    								checkmark.Text = "✓"
    								optionButton.BackgroundColor3 = Color3.fromRGB(70, 120, 70)
    							end
    						else
    							selectedValues = {option.value}
    							updateDisplayText()
    							isOpen = false
    							dropdownFrame.Visible = false
    							arrow.Text = "▼"
    						end
    						updateDisplayText()
    						if flag then
    							if multiSelect then
    								EzUI.Flags[flag] = selectedValues
    							else
    								EzUI.Flags[flag] = selectedValues[1] or ""
    							end
    							if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    								saveConfiguration(EzUI.Configuration.FileName)
    							end
    						end
    						if callback then
    							callback(selectedValues, option.value)
    						end
    						preventAutoClose = false 
    					end)
    					optionButton.MouseEnter:Connect(function()
    						if optionButton.BackgroundColor3 ~= Color3.fromRGB(70, 120, 70) then
    							optionButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    						end
    					end)
    					optionButton.MouseLeave:Connect(function()
    						local isCurrentlySelected = false
    						local optionValue = optionButton:GetAttribute("OptionValue")
    						if type(selectedValues) ~= "table" then
    							selectedValues = {selectedValues}
    						end
    						for _, val in ipairs(selectedValues) do
    							if tostring(val) == tostring(optionValue) then
    								isCurrentlySelected = true
    								break
    							end
    						end
    						if not isCurrentlySelected then
    							optionButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    						end
    					end)
    				end
    				local optionHeight = isForAccordion and 25 or 30
    				dropdownFrame.CanvasSize = UDim2.new(0, 0, 0, #options * optionHeight + 30)
    				wait() 
    				for _, child in pairs(optionsContainer:GetChildren()) do
    					if child:IsA("TextButton") then
    						local optionValue = child:GetAttribute("OptionValue")
    						local checkmark = child:FindFirstChild("TextLabel")
    						local isCurrentlySelected = false
    						if type(selectedValues) ~= "table" then
    							selectedValues = {selectedValues}
    						end
    						for _, value in ipairs(selectedValues) do
    							if tostring(value) == tostring(optionValue) then
    								isCurrentlySelected = true
    								break
    							end
    						end
    						if isCurrentlySelected then
    							if checkmark then checkmark.Text = "✓" end
    							child.BackgroundColor3 = Color3.fromRGB(70, 120, 70)
    						else
    							if checkmark then checkmark.Text = "" end
    							child.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    						end
    					end
    				end
    			end
    			local positionConnection = nil
    			local lastKnownPosition = nil
    			local lastKnownSize = nil
    			local lastKnownViewportSize = nil
    			local function updateDropdownPosition()
    				if isOpen and dropdownFrame.Visible then
    					calculateDropdownPosition()
    				end
    			end
    			local function startPositionTracking()
    				if positionConnection then
    					positionConnection:Disconnect()
    				end
    				local RunService = game:GetService("RunService")
    				positionConnection = RunService.Heartbeat:Connect(function()
    					if isOpen and dropdownFrame.Visible then
    						local currentPosition = selectContainer.AbsolutePosition
    						local currentSize = selectContainer.AbsoluteSize
    						local currentViewportSize = getViewportSize()
    						if not lastKnownPosition or 
    						   currentPosition.X ~= lastKnownPosition.X or 
    						   currentPosition.Y ~= lastKnownPosition.Y or
    						   currentSize.X ~= lastKnownSize.X or
    						   currentSize.Y ~= lastKnownSize.Y or
    						   (lastKnownViewportSize and (
    						       currentViewportSize.X ~= lastKnownViewportSize.X or 
    						       currentViewportSize.Y ~= lastKnownViewportSize.Y
    						   )) then
    							lastKnownPosition = currentPosition
    							lastKnownSize = currentSize
    							lastKnownViewportSize = currentViewportSize
    							local dropdownHeight = isForAccordion and math.min(#options * 25 + 30, 150) or math.min(#options * 30 + 30, 200)
    							dropdownFrame.Size = UDim2.new(0, currentSize.X, 0, dropdownHeight)
    							updateDropdownPosition()
    						end
    					end
    				end)
    			end
    			local function stopPositionTracking()
    				if positionConnection then
    					positionConnection:Disconnect()
    					positionConnection = nil
    				end
    				lastKnownPosition = nil
    				lastKnownSize = nil
    				lastKnownViewportSize = nil
    			end
    			local function toggleDropdown()
    				isOpen = not isOpen
    				dropdownFrame.Visible = isOpen
    				arrow.Text = isOpen and "▲" or "▼"
    				if isOpen then
    					startPositionTracking()
    				else
    					stopPositionTracking()
    				end
    				if isOpen and onDropdownOpen then
    					onDropdownOpen(options, function(newOptions)
    						if newOptions and type(newOptions) == "table" then
    							rawOptions = newOptions
    							options = {}
    							for i, option in ipairs(rawOptions) do
    								if type(option) == "string" then
    									table.insert(options, {text = option, value = option})
    								elseif type(option) == "table" and option.text and option.value then
    									table.insert(options, {text = option.text, value = option.value})
    								end
    							end
    							refreshOptionsDisplay()
    						end
    					end)
    				end
    				if isOpen then
    					local dropdownHeight = isForAccordion and math.min(#options * 25 + 30, 150) or math.min(#options * 30 + 30, 200)
    					dropdownFrame.Size = UDim2.new(0, selectContainer.AbsoluteSize.X, 0, dropdownHeight)
    					calculateDropdownPosition()
    					lastKnownPosition = selectContainer.AbsolutePosition
    					lastKnownSize = selectContainer.AbsoluteSize
    					dropdownFrame.ZIndex = 25
    					searchBox.ZIndex = 26
    					optionsContainer.ZIndex = 26
    					for _, child in pairs(optionsContainer:GetChildren()) do
    						if child:IsA("TextButton") then
    							child.ZIndex = 27
    							local checkmark = child:FindFirstChild("TextLabel")
    							if checkmark then
    								checkmark.ZIndex = 28
    							end
    						end
    					end
    				end
    			end
    			refreshOptionsDisplay()
    			local function filterOptions(searchText)
    				searchText = searchText or ""
    				local originalSearchText = searchText
    				searchText = string.lower(string.gsub(searchText, "^%s*(.-)%s*$", "%1")) 
    				local visibleCount = 0
    				local optionHeight = isForAccordion and 25 or 30
    				local allChildren = optionsContainer:GetChildren()
    				local foundExactMatch = false
    				for i, child in ipairs(allChildren) do
    					if child:IsA("TextButton") then
    						local optionText = child:GetAttribute("OptionText") or ""
    						local optionValue = child:GetAttribute("OptionValue") or ""
    						local shouldShow = false
    						local isExactMatch = false
    						if optionText ~= "" then
    							local optionTextLower = string.lower(optionText)
    							if searchText == "" then
    								shouldShow = true
    								child.Text = "  " .. optionText 
    							else
    								local searchWords = {}
    								for word in string.gmatch(searchText, "%S+") do
    									table.insert(searchWords, word)
    								end
    								local hasMatch = false
    								if #searchWords == 1 then
    									hasMatch = string.find(optionTextLower, searchText, 1, true) ~= nil
    									isExactMatch = optionTextLower == searchText
    								else
    									hasMatch = true
    									for _, word in ipairs(searchWords) do
    										if not string.find(optionTextLower, word, 1, true) then
    											hasMatch = false
    											break
    										end
    									end
    								end
    								shouldShow = hasMatch
    								if hasMatch and searchText ~= "" then
    									if isExactMatch then
    										foundExactMatch = true
    									end
    								end
    							end
    						end
    						if shouldShow then
    							child.Visible = true
    							child.Position = UDim2.new(0, 5, 0, visibleCount * optionHeight)
    							if isExactMatch then
    								child.Position = UDim2.new(0, 5, 0, 0)
    							elseif foundExactMatch then
    								child.Position = UDim2.new(0, 5, 0, (visibleCount + 1) * optionHeight)
    							end
    							visibleCount = visibleCount + 1
    						else
    							child.Visible = false
    						end
    					end
    				end
    				local canvasHeight = math.max(visibleCount * optionHeight + 30, 60) 
    				dropdownFrame.CanvasSize = UDim2.new(0, 0, 0, canvasHeight)
    				selectedIndex = 0
    			end
    			local searchDebounceTime = 0.2 
    			local lastSearchTime = 0
    			searchBox.Changed:Connect(function(property)
    				if property == "Text" then
    					local currentTime = tick()
    					lastSearchTime = currentTime
    					wait(searchDebounceTime)
    					if lastSearchTime == currentTime then
    						filterOptions(searchBox.Text)
    					end
    				end
    			end)
    			local UserInputService = game:GetService("UserInputService")
    			local selectedIndex = 0 
    			local function getVisibleOptions()
    				local visibleOptions = {}
    				for _, child in ipairs(optionsContainer:GetChildren()) do
    					if child:IsA("TextButton") and child.Visible then
    						table.insert(visibleOptions, child)
    					end
    				end
    				return visibleOptions
    			end
    			local function updateHighlight()
    				local visibleOptions = getVisibleOptions()
    				for i, optionButton in ipairs(visibleOptions) do
    					if i == selectedIndex then
    						optionButton.BackgroundColor3 = Color3.fromRGB(70, 120, 200) 
    					else
    						local isSelected = false
    						local optionValue = optionButton:GetAttribute("OptionValue")
    						for _, value in ipairs(selectedValues or {}) do
    							if tostring(optionValue) == tostring(value) then
    								isSelected = true
    								break
    							end
    						end
    						optionButton.BackgroundColor3 = isSelected and Color3.fromRGB(70, 120, 70) or Color3.fromRGB(50, 50, 50)
    					end
    				end
    			end
    			searchBox.Focused:Connect(function()
    				local connection
    				connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    					if gameProcessed then return end
    					local visibleOptions = getVisibleOptions()
    					if #visibleOptions == 0 then return end
    					if input.KeyCode == Enum.KeyCode.Down then
    						selectedIndex = math.min(selectedIndex + 1, #visibleOptions)
    						updateHighlight()
    					elseif input.KeyCode == Enum.KeyCode.Up then
    						selectedIndex = math.max(selectedIndex - 1, 1)
    						updateHighlight()
    					elseif input.KeyCode == Enum.KeyCode.Return then
    						if selectedIndex > 0 and selectedIndex <= #visibleOptions then
    							local selectedOption = visibleOptions[selectedIndex]
    							local clickedOptionValue = selectedOption:GetAttribute("OptionValue")
    							preventAutoClose = true
    							if multiSelect then
    								local isSelected = false
    								local indexToRemove = nil
    								if type(selectedValues) ~= "table" then
    									selectedValues = {selectedValues}
    								end
    								for j, value in ipairs(selectedValues) do
    									if value == clickedOptionValue then
    										isSelected = true
    										indexToRemove = j
    										break
    									end
    								end
    								if isSelected then
    									table.remove(selectedValues, indexToRemove)
    									local checkmark = selectedOption:FindFirstChild("TextLabel")
    									if checkmark then checkmark.Text = "" end
    									selectedOption.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    								else
    									table.insert(selectedValues, clickedOptionValue)
    									local checkmark = selectedOption:FindFirstChild("TextLabel")
    									if checkmark then checkmark.Text = "✓" end
    									selectedOption.BackgroundColor3 = Color3.fromRGB(70, 120, 70)
    								end
    							else
    								selectedValues = {clickedOptionValue}
    								updateDisplayText()
    								isOpen = false
    								dropdownFrame.Visible = false
    								arrow.Text = "▼"
    								stopPositionTracking()
    								searchBox:ReleaseFocus()
    							end
    							updateDisplayText()
    							if callback then
    								callback(selectedValues, clickedOptionValue)
    							end
    							if flag then
    								if multiSelect then
    									EzUI.Flags[flag] = selectedValues
    								else
    									EzUI.Flags[flag] = selectedValues[1] or ""
    								end
    								if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    									saveConfiguration(EzUI.Configuration.FileName)
    								end
    							end
    							preventAutoClose = false
    						end
    					elseif input.KeyCode == Enum.KeyCode.Escape then
    						searchBox:ReleaseFocus()
    						toggleDropdown()
    					end
    				end)
    				searchBox.FocusLost:Connect(function()
    					if connection then
    						connection:Disconnect()
    					end
    					selectedIndex = 0
    					updateHighlight()
    				end)
    			end)
    			local originalToggleDropdown = toggleDropdown
    			toggleDropdown = function()
    				originalToggleDropdown()
    				if not isOpen then
    					searchBox.Text = ""
    					filterOptions("") 
    				end
    			end
    			selectButton.MouseButton1Click:Connect(function()
    				toggleDropdown()
    			end)
    			arrow.MouseButton1Click:Connect(function()
    				toggleDropdown()
    			end)
    			local selectBoxAPI = {
    				GetSelected = function()
    					return selectedValues
    				end,
    				SetSelected = function(values)
    					if values == "" then
    						selectedValues = {} 
    					else
    						selectedValues = values or {}
    					end
    					updateDisplayText()
    					if flag then
    						if multiSelect then
    							EzUI.Flags[flag] = selectedValues
    						else
    							EzUI.Flags[flag] = selectedValues[1] or ""
    						end
    						if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    							saveConfiguration(EzUI.Configuration.FileName)
    						end
    					end
    					for _, child in pairs(optionsContainer:GetChildren()) do
    						if child:IsA("TextButton") then
    							local childOption = nil
    							local childIndex = nil
    							for i, option in ipairs(options) do
    								local optionChild = optionsContainer:GetChildren()[i]
    								if optionChild == child then
    									childOption = option
    									childIndex = i
    									break
    								end
    							end
    							local childCheckmark = child:FindFirstChild("TextLabel")
    							if childCheckmark and childOption then
    								local isSelected = false
    								if type(selectedValues) ~= "table" then
    									selectedValues = {selectedValues}
    								end
    								for _, val in ipairs(selectedValues) do
    									if val == childOption.value then
    										isSelected = true
    										break
    									end
    								end
    								childCheckmark.Text = isSelected and "✓" or ""
    								child.BackgroundColor3 = isSelected and Color3.fromRGB(70, 120, 70) or Color3.fromRGB(50, 50, 50)
    							end
    						end
    					end
    				end,
    				Clear = function()
    					selectedValues = {}
    					updateDisplayText()
    					if flag then
    						if multiSelect then
    							EzUI.Flags[flag] = {}
    						else
    							EzUI.Flags[flag] = ""
    						end
    						if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    							saveConfiguration(EzUI.Configuration.FileName)
    						end
    					end
    					for _, child in pairs(optionsContainer:GetChildren()) do
    						if child:IsA("TextButton") then
    							local checkmark = child:FindFirstChild("TextLabel")
    							if checkmark then
    								checkmark.Text = ""
    							end
    							child.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    						end
    					end
    				end,
    				Refresh = function(newOptions)
    					for _, child in pairs(optionsContainer:GetChildren()) do
    						if child:IsA("TextButton") then
    							child:Destroy()
    						end
    					end
    					rawOptions = newOptions
    					options = {}
    					for i, option in ipairs(rawOptions) do
    						if type(option) == "string" then
    							table.insert(options, {text = option, value = option})
    						elseif type(option) == "table" and option.text and option.value then
    							table.insert(options, {text = option.text, value = option.value})
    						end
    					end
    					for i, option in ipairs(options) do
    						local optionHeight = isForAccordion and 25 or 30
    						local optionButton = Instance.new("TextButton")
    						optionButton.Size = UDim2.new(1, -10, 0, optionHeight)
    						optionButton.Position = UDim2.new(0, 5, 0, (i-1) * optionHeight)
    						optionButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    						optionButton.BorderSizePixel = 0
    						optionButton.Text = "  " .. (option.text or "Unknown")
    						optionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    						optionButton.TextXAlignment = Enum.TextXAlignment.Left
    						optionButton.Font = Enum.Font.SourceSans
    						optionButton.TextSize = isForAccordion and 10 or 12
    						optionButton.ZIndex = 27
    						optionButton.Parent = optionsContainer
    						local checkmark = Instance.new("TextLabel")
    						checkmark.Size = UDim2.new(0, 20, 1, 0)
    						checkmark.Position = UDim2.new(1, -20, 0, 0)
    						checkmark.BackgroundTransparency = 1
    						checkmark.Text = ""
    						checkmark.TextColor3 = Color3.fromRGB(100, 255, 100)
    						checkmark.TextXAlignment = Enum.TextXAlignment.Center
    						checkmark.Font = Enum.Font.SourceSansBold
    						checkmark.TextSize = 12
    						checkmark.ZIndex = 28
    						checkmark.Parent = optionButton
    						checkmark.Visible = multiSelect
    						optionButton.MouseButton1Click:Connect(function()
    							preventAutoClose = true
    							local clickedOptionValue = optionButton:GetAttribute("OptionValue")
    							local clickedOptionText = optionButton:GetAttribute("OptionText")
    							if multiSelect then
    								local isSelected = false
    								local indexToRemove = nil
    								if type(selectedValues) ~= "table" then
    									selectedValues = {selectedValues}
    								end
    								for j, value in ipairs(selectedValues) do
    									if value == clickedOptionValue then
    										isSelected = true
    										indexToRemove = j
    										break
    									end
    								end
    								if isSelected then
    									table.remove(selectedValues, indexToRemove)
    									checkmark.Text = ""
    									optionButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    								else
    									table.insert(selectedValues, clickedOptionValue)
    									checkmark.Text = "✓"
    									optionButton.BackgroundColor3 = Color3.fromRGB(70, 120, 70)
    								end
    							else
    								selectedValues = {clickedOptionValue}
    								updateDisplayText()
    								isOpen = false
    								dropdownFrame.Visible = false
    								arrow.Text = "▼"
    								stopPositionTracking()
    							end
    							updateDisplayText()
    							if callback then
    								callback(selectedValues, clickedOptionValue)
    							end
    								if flag then
    									if multiSelect then
    										EzUI.Flags[flag] = selectedValues
    									else
    										EzUI.Flags[flag] = selectedValues[1] or ""
    									end
    									if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    										saveConfiguration(EzUI.Configuration.FileName)
    									end
    								end							if not multiSelect and not preventAutoClose then
    								spawn(function()
    									wait(0.1)
    									isOpen = false
    									dropdownFrame.Visible = false
    									arrow.Text = "▼"
    									stopPositionTracking()
    								end)
    							end
    							preventAutoClose = false
    						end)
    						optionButton.MouseEnter:Connect(function()
    							if optionButton.BackgroundColor3 ~= Color3.fromRGB(70, 120, 70) then
    								optionButton.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    							end
    						end)
    						optionButton.MouseLeave:Connect(function()
    							local isSelected = false
    							local optionValue = optionButton:GetAttribute("OptionValue")
    							if type(selectedValues) ~= "table" then
    								selectedValues = {selectedValues}
    							end
    							for _, val in ipairs(selectedValues) do
    								if val == optionValue then
    									isSelected = true
    									break
    								end
    							end
    							if not isSelected then
    								optionButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    							end
    						end)
    					end
    					local optionHeight = isForAccordion and 25 or 30
    					dropdownFrame.CanvasSize = UDim2.new(0, 0, 0, #options * optionHeight + 30)
    					selectedValues = {}
    					updateDisplayText()
    				end,
    				Set = function(values)
    					if values == "" then
    						selectedValues = {} 
    					else
    						selectedValues = values or {}
    					end
    					updateDisplayText()
    				end
    			}
    			selectBoxAPI.Cleanup = function()
    				stopPositionTracking()
    				if isOpen then
    					isOpen = false
    					dropdownFrame.Visible = false
    					arrow.Text = "▼"
    				end
    				if selectContainer and selectContainer.Parent then
    					selectContainer:Destroy()
    				end
    			end
    			selectContainer.AncestryChanged:Connect(function()
    				if not selectContainer.Parent then
    					stopPositionTracking()
    				end
    			end)
    			registerComponent(flag, selectBoxAPI)
    			if onInit then
    				local preservedSelectedValues = selectedValues
    				onInit(options, function(newOptions)
    					if newOptions and type(newOptions) == "table" then
    						rawOptions = newOptions
    						options = {}
    						for i, option in ipairs(rawOptions) do
    							if type(option) == "string" then
    								table.insert(options, {text = option, value = option})
    							elseif type(option) == "table" and option.text and option.value then
    								table.insert(options, {text = option.text, value = option.value})
    							end
    						end
    						selectedValues = preservedSelectedValues
    						refreshOptionsDisplay()
    						updateDisplayText()
    					end
    				end, selectBoxAPI)
    			end
    			updateDisplayText()
    			return selectBoxAPI
    		end
    		local function createLabel(text, parentContainer, currentY, updateSizeFunction, animateFunction, isExpanded, isForAccordion)
    			local label = Instance.new("TextLabel")
    			if isForAccordion then
    				label.Size = UDim2.new(1, 0, 0, 25) 
    				label.Position = UDim2.new(0, 0, 0, currentY)
    				label.TextSize = 14
    				label.ZIndex = 5
    			else
    				label.Size = UDim2.new(1, -20, 0, 30) 
    				label.Position = UDim2.new(0, 10, 0, currentY)
    				label.TextSize = 16
    				label.ZIndex = 3
    				label:SetAttribute("ComponentStartY", currentY)
    			end
    			label.BackgroundTransparency = 1
    			label.Text = text
    			label.TextColor3 = Color3.fromRGB(255, 255, 255)
    			label.TextXAlignment = Enum.TextXAlignment.Left
    			label.Font = Enum.Font.SourceSans
    			label.Parent = parentContainer
    			return label
    		end
    		local function createButton(text, callback, parentContainer, currentY, updateSizeFunction, animateFunction, isExpanded, isForAccordion)
    			local button = Instance.new("TextButton")
    			if isForAccordion then
    				button.Size = UDim2.new(0, 100, 0, 25)
    				button.Position = UDim2.new(0, 0, 0, currentY)
    				button.BorderColor3 = Color3.fromRGB(255, 255, 255)
    				button.BorderSizePixel = 2
    				button.TextSize = 12
    				button.ZIndex = 5
    				local buttonCorner = Instance.new("UICorner")
    				buttonCorner.CornerRadius = UDim.new(0, 4)
    				buttonCorner.Parent = button
    				button.MouseEnter:Connect(function()
    					button.BackgroundColor3 = Color3.fromRGB(120, 170, 255)
    				end)
    				button.MouseLeave:Connect(function()
    					button.BackgroundColor3 = Color3.fromRGB(100, 150, 250)
    				end)
    			else
    				button.Size = UDim2.new(0, 120, 0, 30)
    				button.Position = UDim2.new(0, 10, 0, currentY)
    				button.BorderSizePixel = 0
    				button.TextSize = 14
    				button.ZIndex = 3
    				button:SetAttribute("ComponentStartY", currentY)
    			end
    			button.BackgroundColor3 = Color3.fromRGB(100, 150, 250)
    			button.Text = text
    			button.TextColor3 = Color3.fromRGB(255, 255, 255)
    			button.Font = Enum.Font.SourceSans
    			button.Parent = parentContainer
    			if callback then
    				button.MouseButton1Click:Connect(callback)
    			end
    			return button
    		end
    		local function createSeparator(parentContainer, currentY, updateSizeFunction, animateFunction, isExpanded, isForAccordion)
    			local separator = Instance.new("Frame")
    			if isForAccordion then
    				separator.Size = UDim2.new(1, 0, 0, 1) 
    				separator.Position = UDim2.new(0, 0, 0, currentY + 5)
    				separator.ZIndex = 5
    			else
    				separator.Size = UDim2.new(1, -20, 0, 1) 
    				separator.Position = UDim2.new(0, 10, 0, currentY + 5)
    				separator.ZIndex = 3
    				separator:SetAttribute("ComponentStartY", currentY)
    			end
    			separator.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    			separator.BorderSizePixel = 0
    			separator.Parent = parentContainer
    			return separator
    		end
    		local function createToggle(config, parentContainer, currentY, updateSizeFunction, animateFunction, isExpanded, isForAccordion)
    			local text = config.Name or config.Text or "Toggle"
    			local defaultValue = config.Default or false
    			local callback = config.Callback or function() end
    			local flag = config.Flag 
    			local isToggled = defaultValue
    			if flag and EzUI.Flags[flag] ~= nil then
    				isToggled = EzUI.Flags[flag]
    			end
    			local toggleContainer = Instance.new("Frame")
    			if isForAccordion then
    				toggleContainer.Size = UDim2.new(1, -10, 0, 25) 
    				toggleContainer.Position = UDim2.new(0, 5, 0, currentY)
    				toggleContainer.ZIndex = 6
    			else
    				toggleContainer.Size = UDim2.new(1, -20, 0, 30) 
    				toggleContainer.Position = UDim2.new(0, 10, 0, currentY)
    				toggleContainer.ZIndex = 3
    				toggleContainer:SetAttribute("ComponentStartY", currentY)
    			end
    			toggleContainer.BackgroundTransparency = 1
    			toggleContainer.Parent = parentContainer
    			local toggleLabel = Instance.new("TextLabel")
    			if isForAccordion then
    				toggleLabel.Size = UDim2.new(1, -45, 1, 0)
    				toggleLabel.TextSize = 12 
    				toggleLabel.ZIndex = 7
    			else
    				toggleLabel.Size = UDim2.new(1, -60, 1, 0)
    				toggleLabel.TextSize = 16 
    				toggleLabel.ZIndex = 4
    			end
    			toggleLabel.Position = UDim2.new(0, 0, 0, 0)
    			toggleLabel.BackgroundTransparency = 1
    			toggleLabel.Text = text
    			toggleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    			toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
    			toggleLabel.Font = Enum.Font.SourceSans
    			toggleLabel.Parent = toggleContainer
    			local toggleBg = Instance.new("Frame")
    			if isForAccordion then
    				toggleBg.Size = UDim2.new(0, 40, 0, 20) 
    				toggleBg.Position = UDim2.new(1, -40, 0.5, -10)
    				toggleBg.ZIndex = 7
    			else
    				toggleBg.Size = UDim2.new(0, 50, 0, 24) 
    				toggleBg.Position = UDim2.new(1, -50, 0.5, -12)
    				toggleBg.ZIndex = 4
    			end
    			toggleBg.BackgroundColor3 = isToggled and Color3.fromRGB(76, 175, 80) or Color3.fromRGB(100, 100, 100)
    			toggleBg.BorderSizePixel = 0
    			toggleBg.Parent = toggleContainer
    			local toggleBgCorner = Instance.new("UICorner")
    			toggleBgCorner.CornerRadius = UDim.new(0, isForAccordion and 10 or 12)
    			toggleBgCorner.Parent = toggleBg
    			local toggleButton = Instance.new("TextButton")
    			if isForAccordion then
    				toggleButton.Size = UDim2.new(0, 16, 0, 16) 
    				toggleButton.Position = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
    				toggleButton.ZIndex = 8
    			else
    				toggleButton.Size = UDim2.new(0, 20, 0, 20) 
    				toggleButton.Position = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
    				toggleButton.ZIndex = 5
    			end
    			toggleButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    			toggleButton.BorderSizePixel = 0
    			toggleButton.Text = ""
    			toggleButton.Parent = toggleBg
    			local toggleButtonCorner = Instance.new("UICorner")
    			toggleButtonCorner.CornerRadius = UDim.new(0, isForAccordion and 8 or 10)
    			toggleButtonCorner.Parent = toggleButton
    			local function updateToggleAppearance()
    				local targetBgColor = isToggled and Color3.fromRGB(76, 175, 80) or Color3.fromRGB(100, 100, 100)
    				local targetPosition
    				if isForAccordion then
    					targetPosition = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
    				else
    					targetPosition = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
    				end
    				local bgTween = game:GetService("TweenService"):Create(
    					toggleBg,
    					TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    					{BackgroundColor3 = targetBgColor}
    				)
    				bgTween:Play()
    				local buttonTween = game:GetService("TweenService"):Create(
    					toggleButton,
    					TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    					{Position = targetPosition}
    				)
    				buttonTween:Play()
    			end
    			toggleButton.MouseButton1Click:Connect(function()
    				isToggled = not isToggled
    				updateToggleAppearance()
    				if flag then
    					EzUI.Flags[flag] = isToggled
    					if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    						saveConfiguration(EzUI.Configuration.FileName)
    					end
    				end
    				local success, errorMsg = pcall(function()
    					callback(isToggled)
    				end)
    				if not success then
    					warn("Toggle callback error:", errorMsg)
    				end
    			end)
    			toggleBg.InputBegan:Connect(function(input)
    				if input.UserInputType == Enum.UserInputType.MouseButton1 then
    					isToggled = not isToggled
    					updateToggleAppearance()
    					if flag then
    						EzUI.Flags[flag] = isToggled
    						if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    							saveConfiguration(EzUI.Configuration.FileName)
    						end
    					end
    					local success, errorMsg = pcall(function()
    						callback(isToggled)
    					end)
    					if not success then
    						warn("Toggle callback error:", errorMsg)
    					end
    				end
    			end)
    			toggleButton.MouseEnter:Connect(function()
    				toggleButton.BackgroundColor3 = Color3.fromRGB(245, 245, 245)
    			end)
    			toggleButton.MouseLeave:Connect(function()
    				toggleButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    			end)
    			local toggleAPI = {}
    			toggleAPI.SetValue = function(newValue)
    				if type(newValue) == "boolean" and newValue ~= isToggled then
    					isToggled = newValue
    					updateToggleAppearance()
    					if flag then
    						EzUI.Flags[flag] = isToggled
    						if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    							saveConfiguration(EzUI.Configuration.FileName)
    						end
    					end
    				end
    			end
    			toggleAPI.GetValue = function()
    				return isToggled
    			end
    			toggleAPI.SetText = function(newText)
    				text = newText
    				toggleLabel.Text = newText
    			end
    			toggleAPI.SetCallback = function(newCallback)
    				callback = newCallback or function() end
    			end
    			toggleAPI.Set = toggleAPI.SetValue
    			registerComponent(flag, toggleAPI)
    			return toggleAPI
    		end
    		local function createTextBox(config, parentContainer, currentY, updateSizeFunction, animateFunction, isExpanded, isForAccordion)
    			local placeholder = config.Placeholder or "Enter text..."
    			local defaultText = config.Default or ""
    			local callback = config.Callback or function() end
    			local maxLength = config.MaxLength or 100
    			local multiline = config.Multiline or false
    			local flag = config.Flag
    			local currentText = defaultText
    			if flag and EzUI.Flags[flag] ~= nil then
    				currentText = EzUI.Flags[flag]
    				defaultText = currentText
    			end
    			local textBoxContainer = Instance.new("Frame")
    			if isForAccordion then
    				textBoxContainer.Size = UDim2.new(1, -10, 0, multiline and 60 or 25) 
    				textBoxContainer.Position = UDim2.new(0, 5, 0, currentY)
    				textBoxContainer.ZIndex = 6
    			else
    				textBoxContainer.Size = UDim2.new(1, -20, 0, multiline and 80 or 30) 
    				textBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
    				textBoxContainer.ZIndex = 3
    				textBoxContainer:SetAttribute("ComponentStartY", currentY)
    			end
    			textBoxContainer.BackgroundTransparency = 1
    			textBoxContainer.Parent = parentContainer
    			local textBox = Instance.new("TextBox")
    			textBox.Size = UDim2.new(1, 0, 1, 0)
    			textBox.Position = UDim2.new(0, 0, 0, 0)
    			textBox.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    			textBox.BorderColor3 = Color3.fromRGB(100, 100, 100)
    			textBox.BorderSizePixel = 1
    			textBox.Text = defaultText
    			textBox.PlaceholderText = placeholder
    			textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    			textBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
    			textBox.Font = Enum.Font.SourceSans
    			textBox.TextSize = isForAccordion and 12 or 14 
    			textBox.TextXAlignment = Enum.TextXAlignment.Left
    			textBox.TextYAlignment = multiline and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
    			textBox.MultiLine = multiline
    			textBox.TextWrapped = multiline
    			textBox.ClearTextOnFocus = false
    			textBox.ZIndex = isForAccordion and 7 or 4
    			textBox.Parent = textBoxContainer
    			local corner = Instance.new("UICorner")
    			corner.CornerRadius = UDim.new(0, 4)
    			corner.Parent = textBox
    			local charCounter = nil
    			if maxLength and maxLength > 0 then
    				charCounter = Instance.new("TextLabel")
    				charCounter.Size = UDim2.new(0, 50, 0, 15)
    				charCounter.Position = UDim2.new(1, -55, 1, -18)
    				charCounter.BackgroundTransparency = 1
    				charCounter.Text = string.len(currentText) .. "/" .. maxLength
    				charCounter.TextColor3 = Color3.fromRGB(150, 150, 150)
    				charCounter.Font = Enum.Font.SourceSans
    				charCounter.TextSize = isForAccordion and 10 or 12 
    				charCounter.TextXAlignment = Enum.TextXAlignment.Right
    				charCounter.ZIndex = isForAccordion and 8 or 5
    				charCounter.Parent = textBoxContainer
    			end
    			local function updateCharCounter()
    				if charCounter then
    					local textLength = string.len(textBox.Text)
    					charCounter.Text = textLength .. "/" .. maxLength
    					if textLength >= maxLength then
    						charCounter.TextColor3 = Color3.fromRGB(255, 100, 100) 
    					elseif textLength >= maxLength * 0.8 then
    						charCounter.TextColor3 = Color3.fromRGB(255, 200, 100) 
    					else
    						charCounter.TextColor3 = Color3.fromRGB(150, 150, 150) 
    					end
    				end
    			end
    			textBox.Changed:Connect(function(property)
    				if property == "Text" then
    					if maxLength and maxLength > 0 and string.len(textBox.Text) > maxLength then
    						textBox.Text = string.sub(textBox.Text, 1, maxLength)
    					end
    					currentText = textBox.Text
    					updateCharCounter()
    					if flag then
    						EzUI.Flags[flag] = currentText
    						if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    							saveConfiguration(EzUI.Configuration.FileName)
    						end
    					end
    					local success, errorMsg = pcall(function()
    						callback(currentText)
    					end)
    					if not success then
    						warn("TextBox callback error:", errorMsg)
    					end
    				end
    			end)
    			textBox.Focused:Connect(function()
    				textBox.BorderColor3 = Color3.fromRGB(100, 150, 250)
    			end)
    			textBox.FocusLost:Connect(function()
    				textBox.BorderColor3 = Color3.fromRGB(100, 100, 100)
    			end)
    			local textBoxAPI = {
    				GetText = function()
    					return currentText
    				end,
    				SetText = function(newText)
    					textBox.Text = tostring(newText or "")
    					currentText = textBox.Text
    					updateCharCounter()
    					if flag then
    						EzUI.Flags[flag] = currentText
    						if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    							saveConfiguration(EzUI.Configuration.FileName)
    						end
    					end
    				end,
    				Clear = function()
    					textBox.Text = ""
    					currentText = ""
    					updateCharCounter()
    					if flag then
    						EzUI.Flags[flag] = currentText
    						if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    							saveConfiguration(EzUI.Configuration.FileName)
    						end
    					end
    				end,
    				SetPlaceholder = function(newPlaceholder)
    					textBox.PlaceholderText = tostring(newPlaceholder or "")
    				end,
    				Focus = function()
    					textBox:CaptureFocus()
    				end,
    				Blur = function()
    					textBox:ReleaseFocus()
    				end,
    				SetCallback = function(newCallback)
    					callback = newCallback or function() end
    				end,
    				Set = function(newText)
    					textBox.Text = tostring(newText or "")
    					currentText = textBox.Text
    					updateCharCounter()
    				end
    			}
    			registerComponent(flag, textBoxAPI)
    			return textBoxAPI
    		end
    		local function createNumberBox(config, parentContainer, currentY, updateSizeFunction, animateFunction, isExpanded, isForAccordion)
    			local placeholder = config.Placeholder or "Enter number..."
    			local defaultValue = config.Default or 0
    			local callback = config.Callback or function() end
    			local minValue = config.Min or -math.huge
    			local maxValue = config.Max or math.huge
    			local increment = config.Increment or 1
    			local decimals = config.Decimals or 0
    			local flag = config.Flag
    			local currentValue = defaultValue
    			if flag and EzUI.Flags[flag] ~= nil then
    				currentValue = EzUI.Flags[flag]
    				defaultValue = currentValue
    			end
    			local numberBoxContainer = Instance.new("Frame")
    			if isForAccordion then
    				numberBoxContainer.Size = UDim2.new(1, -10, 0, 25) 
    				numberBoxContainer.Position = UDim2.new(0, 5, 0, currentY)
    				numberBoxContainer.ZIndex = 6
    			else
    				numberBoxContainer.Size = UDim2.new(1, -20, 0, 30) 
    				numberBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
    				numberBoxContainer.ZIndex = 3
    				numberBoxContainer:SetAttribute("ComponentStartY", currentY)
    			end
    			numberBoxContainer.BackgroundTransparency = 1
    			numberBoxContainer.Parent = parentContainer
    			local numberBox = Instance.new("TextBox")
    			if isForAccordion then
    				numberBox.Size = UDim2.new(1, -45, 1, 0) 
    				numberBox.TextSize = 12 
    				numberBox.ZIndex = 7
    			else
    				numberBox.Size = UDim2.new(1, -60, 1, 0) 
    				numberBox.TextSize = 14 
    				numberBox.ZIndex = 4
    			end
    			numberBox.Position = UDim2.new(0, 0, 0, 0)
    			numberBox.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    			numberBox.BorderColor3 = Color3.fromRGB(100, 100, 100)
    			numberBox.BorderSizePixel = 1
    			numberBox.Text = decimals > 0 and string.format("%." .. decimals .. "f", defaultValue) or tostring(defaultValue)
    			numberBox.PlaceholderText = placeholder
    			numberBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    			numberBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
    			numberBox.Font = Enum.Font.SourceSans
    			numberBox.TextXAlignment = Enum.TextXAlignment.Center
    			numberBox.TextYAlignment = Enum.TextYAlignment.Center
    			numberBox.ClearTextOnFocus = false
    			numberBox.Parent = numberBoxContainer
    			local numberCorner = Instance.new("UICorner")
    			numberCorner.CornerRadius = UDim.new(0, 4)
    			numberCorner.Parent = numberBox
    			local incrementBtn = Instance.new("TextButton")
    			if isForAccordion then
    				incrementBtn.Size = UDim2.new(0, 20, 0, 12) 
    				incrementBtn.Position = UDim2.new(1, -22, 0, 1)
    				incrementBtn.TextSize = 8
    				incrementBtn.ZIndex = 7
    			else
    				incrementBtn.Size = UDim2.new(0, 25, 0, 14) 
    				incrementBtn.Position = UDim2.new(1, -30, 0, 1)
    				incrementBtn.TextSize = 10
    				incrementBtn.ZIndex = 4
    			end
    			incrementBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    			incrementBtn.BorderColor3 = Color3.fromRGB(100, 100, 100)
    			incrementBtn.BorderSizePixel = 1
    			incrementBtn.Text = "▲"
    			incrementBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
    			incrementBtn.Font = Enum.Font.SourceSans
    			incrementBtn.Parent = numberBoxContainer
    			local decrementBtn = Instance.new("TextButton")
    			if isForAccordion then
    				decrementBtn.Size = UDim2.new(0, 20, 0, 12) 
    				decrementBtn.Position = UDim2.new(1, -22, 0, 13)
    				decrementBtn.TextSize = 8
    				decrementBtn.ZIndex = 7
    			else
    				decrementBtn.Size = UDim2.new(0, 25, 0, 14) 
    				decrementBtn.Position = UDim2.new(1, -30, 0, 15)
    				decrementBtn.TextSize = 10
    				decrementBtn.ZIndex = 4
    			end
    			decrementBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    			decrementBtn.BorderColor3 = Color3.fromRGB(100, 100, 100)
    			decrementBtn.BorderSizePixel = 1
    			decrementBtn.Text = "▼"
    			decrementBtn.TextColor3 = Color3.fromRGB(200, 200, 200)
    			decrementBtn.Font = Enum.Font.SourceSans
    			decrementBtn.Parent = numberBoxContainer
    			local function updateValue(newValue)
    				newValue = math.max(minValue, math.min(maxValue, newValue))
    				if decimals > 0 then
    					local multiplier = 10 ^ decimals
    					newValue = math.floor(newValue * multiplier + 0.5) / multiplier
    				else
    					newValue = math.floor(newValue + 0.5)
    				end
    				currentValue = newValue
    				if decimals > 0 then
    					numberBox.Text = string.format("%." .. decimals .. "f", newValue)
    				else
    					numberBox.Text = tostring(newValue)
    				end
    				if flag then
    					EzUI.Flags[flag] = currentValue
    					if EzUI.Configuration.Enabled and EzUI.Configuration.AutoSave then
    						saveConfiguration(EzUI.Configuration.FileName)
    					end
    				end
    				local success, errorMsg = pcall(function()
    					callback(currentValue)
    				end)
    				if not success then
    					warn("NumberBox callback error:", errorMsg)
    				end
    				return newValue
    			end
    			numberBox.FocusLost:Connect(function()
    				local inputText = numberBox.Text
    				local numValue = tonumber(inputText)
    				if numValue then
    					updateValue(numValue)
    				else
    					if decimals > 0 then
    						numberBox.Text = string.format("%." .. decimals .. "f", currentValue)
    					else
    						numberBox.Text = tostring(currentValue)
    					end
    				end
    			end)
    			incrementBtn.MouseButton1Click:Connect(function()
    				updateValue(currentValue + increment)
    			end)
    			decrementBtn.MouseButton1Click:Connect(function()
    				updateValue(currentValue - increment)
    			end)
    			incrementBtn.MouseEnter:Connect(function()
    				incrementBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    			end)
    			incrementBtn.MouseLeave:Connect(function()
    				incrementBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    			end)
    			decrementBtn.MouseEnter:Connect(function()
    				decrementBtn.BackgroundColor3 = Color3.fromRGB(100, 100, 100)
    			end)
    			decrementBtn.MouseLeave:Connect(function()
    				decrementBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 80)
    			end)
    			numberBox.Focused:Connect(function()
    				numberBox.BorderColor3 = Color3.fromRGB(100, 150, 250)
    			end)
    			numberBox.FocusLost:Connect(function()
    				numberBox.BorderColor3 = Color3.fromRGB(100, 100, 100)
    			end)
    			local numberBoxAPI = {
    				GetValue = function()
    					return currentValue
    				end,
    				SetValue = function(newValue)
    					local numValue = tonumber(newValue)
    					if numValue then
    						updateValue(numValue)
    					else
    						warn("NumberBox SetValue: Expected number, got " .. type(newValue))
    					end
    				end,
    				SetMin = function(newMin)
    					minValue = tonumber(newMin) or -math.huge
    					updateValue(currentValue) 
    				end,
    				SetMax = function(newMax)
    					maxValue = tonumber(newMax) or math.huge
    					updateValue(currentValue) 
    				end,
    				SetIncrement = function(newIncrement)
    					increment = tonumber(newIncrement) or 1
    				end,
    				Clear = function()
    					updateValue(0)
    				end,
    				Focus = function()
    					numberBox:CaptureFocus()
    				end,
    				Blur = function()
    					numberBox:ReleaseFocus()
    				end,
    				SetCallback = function(newCallback)
    					callback = newCallback or function() end
    				end,
    				Set = function(newValue)
    					local numValue = tonumber(newValue)
    					if numValue then
    						updateValue(numValue)
    					end
    				end
    			}
    			registerComponent(flag, numberBoxAPI)
    			return numberBoxAPI
    		end
    		local tabAPI = {}
    		function tabAPI:AddLabel(text)
    			local label = createLabel(text, tabContent, tabCurrentY, nil, nil, nil, false)
    			tabCurrentY = tabCurrentY + 35
    			if tabContent == activeTab then
    				currentY = tabCurrentY
    				api:UpdateWindowSize()
    			end
    			return {
    				SetText = function(newText)
    					label.Text = newText
    				end,
    				SetColor = function(color)
    					label.TextColor3 = color
    				end,
    				GetText = function()
    					return label.Text
    				end
    			}
    		end
    		function tabAPI:AddButton(text, callback)
    			local button = createButton(text, callback, tabContent, tabCurrentY, nil, nil, nil, false)
    			tabCurrentY = tabCurrentY + 35
    			if tabContent == activeTab then
    				currentY = tabCurrentY
    				api:UpdateWindowSize()
    			end
    		end
    		function tabAPI:AddSelectBox(config)
    			local selectBoxAPI = createSelectBox(
    				config, 
    				tabContent, 
    				tabCurrentY, 
    				function() 
    					if tabContent == activeTab then
    						currentY = tabCurrentY
    						api:UpdateWindowSize()
    					end
    				end, 
    				nil, 
    				true, 
    				false 
    			)
    			tabCurrentY = tabCurrentY + 40
    			if tabContent == activeTab then
    				currentY = tabCurrentY
    				api:UpdateWindowSize()
    			end
    			return selectBoxAPI
    		end
    		function tabAPI:AddToggle(config)
    			local toggleAPI = createToggle(config, tabContent, tabCurrentY, nil, nil, nil, false)
    			tabCurrentY = tabCurrentY + 35
    			if tabContent == activeTab then
    				currentY = tabCurrentY
    				api:UpdateWindowSize()
    			end
    			return toggleAPI
    		end
    		function tabAPI:AddTextBox(config)
    			local textBoxAPI = createTextBox(config, tabContent, tabCurrentY, nil, nil, nil, false)
    			local multiline = config.Multiline or false
    			tabCurrentY = tabCurrentY + (multiline and 90 or 40)
    			if tabContent == activeTab then
    				currentY = tabCurrentY
    				api:UpdateWindowSize()
    			end
    			return textBoxAPI
    		end
    		function tabAPI:AddNumberBox(config)
    			local numberBoxAPI = createNumberBox(config, tabContent, tabCurrentY, nil, nil, nil, false)
    			tabCurrentY = tabCurrentY + 40
    			if tabContent == activeTab then
    				currentY = tabCurrentY
    				api:UpdateWindowSize()
    			end
    			return numberBoxAPI
    		end
    		function tabAPI:AddSeparator()
    			local separator = createSeparator(tabContent, tabCurrentY, nil, nil, nil, false)
    			tabCurrentY = tabCurrentY + 15
    			if tabContent == activeTab then
    				currentY = tabCurrentY
    				api:UpdateWindowSize()
    			end
    		end
    		function tabAPI:AddAccordion(config)
    			local title = config.Title or config.Name or "Accordion"
    			local expanded = config.Expanded ~= nil and config.Expanded or false
    			local callback = config.Callback or function() end
    			local icon = config.Icon or "📁" 
    			local isExpanded = expanded
    			local accordionContentHeight = 0
    			local accordionStartY = tabCurrentY 
    			local accordionContainer = Instance.new("Frame")
    			accordionContainer.Size = UDim2.new(1, -20, 0, 30) 
    			accordionContainer.Position = UDim2.new(0, 10, 0, tabCurrentY)
    			accordionContainer.BackgroundTransparency = 1
    			accordionContainer.ClipsDescendants = false 
    			accordionContainer.ZIndex = 3
    			accordionContainer.Parent = tabContent
    			accordionContainer:SetAttribute("AccordionStartY", tabCurrentY)
    			accordionContainer:SetAttribute("IsAccordion", true)
    			local accordionHeader = Instance.new("TextButton")
    			accordionHeader.Size = UDim2.new(1, 0, 0, 30)
    			accordionHeader.Position = UDim2.new(0, 0, 0, 0)
    			accordionHeader.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    			accordionHeader.BorderColor3 = Color3.fromRGB(100, 100, 100)
    			accordionHeader.BorderSizePixel = 1
    			accordionHeader.Text = "" 
    			accordionHeader.ZIndex = 4
    			accordionHeader.Parent = accordionContainer
    			local accordionArrow = Instance.new("TextLabel")
    			accordionArrow.Size = UDim2.new(0, 30, 1, 0)
    			accordionArrow.Position = UDim2.new(0, 5, 0, 0)
    			accordionArrow.BackgroundTransparency = 1
    			accordionArrow.Text = isExpanded and "▼" or "▶"
    			accordionArrow.TextColor3 = Color3.fromRGB(200, 200, 200)
    			accordionArrow.TextXAlignment = Enum.TextXAlignment.Center
    			accordionArrow.Font = Enum.Font.SourceSans
    			accordionArrow.TextSize = 14
    			accordionArrow.ZIndex = 5
    			accordionArrow.Parent = accordionHeader
    			local accordionIcon = Instance.new("TextLabel")
    			accordionIcon.Size = UDim2.new(0, 25, 1, 0)
    			accordionIcon.Position = UDim2.new(0, 35, 0, 0)
    			accordionIcon.BackgroundTransparency = 1
    			accordionIcon.Text = icon
    			accordionIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
    			accordionIcon.TextXAlignment = Enum.TextXAlignment.Center
    			accordionIcon.Font = Enum.Font.SourceSans
    			accordionIcon.TextSize = 16
    			accordionIcon.ZIndex = 5
    			accordionIcon.Parent = accordionHeader
    			local accordionTitle = Instance.new("TextLabel")
    			accordionTitle.Size = UDim2.new(1, -70, 1, 0)
    			accordionTitle.Position = UDim2.new(0, 65, 0, 0)
    			accordionTitle.BackgroundTransparency = 1
    			accordionTitle.Text = title
    			accordionTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
    			accordionTitle.TextXAlignment = Enum.TextXAlignment.Left
    			accordionTitle.Font = Enum.Font.SourceSansBold
    			accordionTitle.TextSize = 16
    			accordionTitle.ZIndex = 5
    			accordionTitle.Parent = accordionHeader
    			local accordionContent = Instance.new("ScrollingFrame")
    			accordionContent.Size = UDim2.new(1, 0, 0, 0) 
    			accordionContent.Position = UDim2.new(0, 0, 0, 35) 
    			accordionContent.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    			accordionContent.BorderColor3 = Color3.fromRGB(80, 80, 80)
    			accordionContent.BorderSizePixel = 1
    			accordionContent.Visible = isExpanded
    			accordionContent.CanvasSize = UDim2.new(0, 0, 0, 0)
    			accordionContent.ScrollBarThickness = 6
    			accordionContent.ScrollBarImageColor3 = Color3.fromRGB(120, 120, 120)
    			accordionContent.ScrollingDirection = Enum.ScrollingDirection.Y
    			accordionContent.VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar
    			accordionContent.ZIndex = 4
    			accordionContent.Parent = accordionContainer
    			local contentCorner = Instance.new("UICorner")
    			contentCorner.CornerRadius = UDim.new(0, 4)
    			contentCorner.Parent = accordionContent
    			local contentPadding = Instance.new("UIPadding")
    			contentPadding.PaddingTop = UDim.new(0, 8)
    			contentPadding.PaddingBottom = UDim.new(0, 8)
    			contentPadding.PaddingLeft = UDim.new(0, 8)
    			contentPadding.PaddingRight = UDim.new(0, 8)
    			contentPadding.Parent = accordionContent
    			local contentLayout = Instance.new("UIListLayout")
    			contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
    			contentLayout.Padding = UDim.new(0, 5)
    			contentLayout.Parent = accordionContent
    			local accordionCurrentY = 10
    			local function updateComponentsBelow()
    				local currentAccordionBottom = accordionContainer.Position.Y.Offset + accordionContainer.Size.Y.Offset
    				local accordionHeightChange = accordionContainer.Size.Y.Offset - 35 
    				for _, child in pairs(tabContent:GetChildren()) do
    					if child:IsA("GuiObject") and child ~= accordionContainer then
    						local childCurrentY = child.Position.Y.Offset
    						local accordionHeaderBottom = accordionStartY + 35 
    						if childCurrentY > accordionHeaderBottom then
    							local newY = accordionStartY + accordionContainer.Size.Y.Offset + 5 + (childCurrentY - accordionHeaderBottom - 5)
    							child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, newY)
    						end
    					end
    				end
    			end
    			local function recalculateTabHeight()
    				local maxY = 10
    				for _, child in pairs(tabContent:GetChildren()) do
    					if child:IsA("GuiObject") then
    						local childBottom = child.Position.Y.Offset + child.Size.Y.Offset
    						maxY = math.max(maxY, childBottom)
    					end
    				end
    				tabCurrentY = maxY + 10
    				if tabContent == activeTab then
    					currentY = tabCurrentY
    					api:UpdateWindowSize()
    				end
    			end
    			local function updateAccordionSize()
    				accordionContent.CanvasSize = UDim2.new(0, 0, 0, accordionCurrentY + 10)
    				accordionContentHeight = math.min(accordionCurrentY + 20, 150)
    				local totalHeight = 35 + (isExpanded and accordionContentHeight or 0) 
    				accordionContainer.Size = UDim2.new(1, -20, 0, totalHeight)
    				if isExpanded then
    					accordionContent.Size = UDim2.new(1, 0, 0, accordionContentHeight)
    				end
    				updateComponentsBelow()
    				recalculateTabHeight()
    			end
    			local function animateAccordion()
    				local TweenService = game:GetService("TweenService")
    				local oldContainerHeight = accordionContainer.Size.Y.Offset
    				local targetContentHeight = isExpanded and accordionContentHeight or 0
    				local targetContainerHeight = 35 + targetContentHeight
    				local heightDifference = targetContainerHeight - oldContainerHeight
    				local componentsBelow = {}
    				local accordionBottom = accordionContainer.Position.Y.Offset + oldContainerHeight
    				for _, child in pairs(tabContent:GetChildren()) do
    					if child:IsA("GuiObject") and child ~= accordionContainer then
    						local childY = child.Position.Y.Offset
    						if childY > accordionBottom then
    							table.insert(componentsBelow, {
    								component = child,
    								currentY = childY,
    								targetY = childY + heightDifference
    							})
    						end
    					end
    				end
    				accordionArrow.Text = isExpanded and "▼" or "▶"
    				if isExpanded then
    					accordionContent.Visible = true
    				end
    				local containerTween = TweenService:Create(
    					accordionContainer,
    					TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    					{Size = UDim2.new(1, -20, 0, targetContainerHeight)}
    				)
    				local contentTween = TweenService:Create(
    					accordionContent,
    					TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    					{Size = UDim2.new(1, 0, 0, targetContentHeight)}
    				)
    				for _, componentData in ipairs(componentsBelow) do
    					local componentTween = TweenService:Create(
    						componentData.component,
    						TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
    						{Position = UDim2.new(componentData.component.Position.X.Scale, componentData.component.Position.X.Offset, 0, componentData.targetY)}
    					)
    					componentTween:Play()
    				end
    				containerTween:Play()
    				contentTween:Play()
    				if not isExpanded then
    					containerTween.Completed:Connect(function()
    						accordionContent.Visible = false
    					end)
    				end
    				containerTween.Completed:Connect(function()
    					recalculateTabHeight()
    				end)
    			end
    			accordionHeader.MouseButton1Click:Connect(function()
    				isExpanded = not isExpanded
    				local success, errorMsg = pcall(function()
    					callback(isExpanded)
    				end)
    				if not success then
    					warn("Accordion callback error:", errorMsg)
    				end
    				animateAccordion()
    			end)
    			accordionHeader.MouseEnter:Connect(function()
    				accordionHeader.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    			end)
    			accordionHeader.MouseLeave:Connect(function()
    				accordionHeader.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
    			end)
    			tabCurrentY = tabCurrentY + 40 
    			local accordionAPI = {}
    			function accordionAPI:AddLabel(text)
    				local label = createLabel(text, accordionContent, accordionCurrentY, updateAccordionSize, animateAccordion, isExpanded, true)
    				accordionCurrentY = accordionCurrentY + 30
    				updateAccordionSize()
    				if isExpanded then
    					animateAccordion()
    				end
    				return {
    					SetText = function(newText)
    						label.Text = newText
    					end,
    					SetColor = function(color)
    						label.TextColor3 = color
    					end,
    					GetText = function()
    						return label.Text
    					end
    				}
    			end
    			function accordionAPI:AddButton(text, buttonCallback)
    				local button = createButton(text, buttonCallback, accordionContent, accordionCurrentY, updateAccordionSize, animateAccordion, isExpanded, true)
    				accordionCurrentY = accordionCurrentY + 30
    				updateAccordionSize()
    				if isExpanded then
    					animateAccordion()
    				end
    			end
    			function accordionAPI:AddSelectBox(config)
    				local selectBoxAPI = createSelectBox(
    					config, 
    					accordionContent, 
    					accordionCurrentY, 
    					updateAccordionSize, 
    					animateAccordion, 
    					isExpanded, 
    					true 
    				)
    				accordionCurrentY = accordionCurrentY + 35 
    				updateAccordionSize()
    				if isExpanded then
    					animateAccordion()
    				end
    				return selectBoxAPI
    			end
    			function accordionAPI:AddSeparator()
    				local separator = createSeparator(accordionContent, accordionCurrentY, updateAccordionSize, animateAccordion, isExpanded, true)
    				accordionCurrentY = accordionCurrentY + 15
    				updateAccordionSize()
    				if isExpanded then
    					animateAccordion()
    				end
    			end
    			function accordionAPI:AddToggle(config)
    				local toggleAPI = createToggle(config, accordionContent, accordionCurrentY, updateAccordionSize, animateAccordion, isExpanded, true)
    				accordionCurrentY = accordionCurrentY + 30
    				updateAccordionSize()
    				if isExpanded then
    					animateAccordion()
    				end
    				return toggleAPI
    			end
    			function accordionAPI:AddTextBox(config)
    				local textBoxAPI = createTextBox(config, accordionContent, accordionCurrentY, updateAccordionSize, animateAccordion, isExpanded, true)
    				local multiline = config.Multiline or false
    				accordionCurrentY = accordionCurrentY + (multiline and 70 or 35) 
    				updateAccordionSize()
    				if isExpanded then
    					animateAccordion()
    				end
    				return textBoxAPI
    			end
    			function accordionAPI:AddNumberBox(config)
    				local numberBoxAPI = createNumberBox(config, accordionContent, accordionCurrentY, updateAccordionSize, animateAccordion, isExpanded, true)
    				accordionCurrentY = accordionCurrentY + 35 
    				updateAccordionSize()
    				if isExpanded then
    					animateAccordion()
    				end
    				return numberBoxAPI
    			end
    			if isExpanded then
    				updateAccordionSize()
    				animateAccordion()
    			end
    			return {
    				Expand = function()
    					if not isExpanded then
    						isExpanded = true
    						animateAccordion()
    						local success, errorMsg = pcall(function()
    							callback(isExpanded)
    						end)
    						if not success then
    							warn("Accordion callback error:", errorMsg)
    						end
    					end
    				end,
    				Collapse = function()
    					if isExpanded then
    						isExpanded = false
    						animateAccordion()
    						local success, errorMsg = pcall(function()
    							callback(isExpanded)
    						end)
    						if not success then
    							warn("Accordion callback error:", errorMsg)
    						end
    					end
    				end,
    				Toggle = function()
    					isExpanded = not isExpanded
    					animateAccordion()
    					local success, errorMsg = pcall(function()
    						callback(isExpanded)
    					end)
    					if not success then
    						warn("Accordion callback error:", errorMsg)
    					end
    					return isExpanded
    				end,
    				IsExpanded = function()
    					return isExpanded
    				end,
    				SetTitle = function(newTitle)
    					title = newTitle
    					accordionTitle.Text = newTitle
    				end,
    				SetIcon = function(newIcon)
    					icon = newIcon
    					accordionIcon.Text = newIcon
    				end,
    				AddLabel = accordionAPI.AddLabel,
    				AddButton = accordionAPI.AddButton,
    				AddSelectBox = accordionAPI.AddSelectBox,
    				AddSeparator = accordionAPI.AddSeparator,
    				AddToggle = accordionAPI.AddToggle,
    				AddTextBox = accordionAPI.AddTextBox,
    				AddNumberBox = accordionAPI.AddNumberBox
    			}
    		end
    		tabBtn.MouseButton1Click:Connect(function()
    			for _, content in pairs(tabContents) do
    				content.Visible = false
    			end
    			for _, btn in pairs(tabScrollFrame:GetChildren()) do
    				if btn:IsA("TextButton") then
    					btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    				end
    			end
    			tabContent.Visible = true
    			tabBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    			activeTab = tabContent
    			activeTabName = tabName
    			currentTabContent = tabContent
    			currentY = tabCurrentY
    			api:UpdateWindowSize()
    			if tabCallback then
    				local success, errorMsg = pcall(function()
    					tabCallback(tabName, true) 
    				end)
    				if not success then
    					warn("Tab callback error:", errorMsg)
    				end
    			end
    		end)
    		if not activeTab then
    			tabContent.Visible = true
    			activeTab = tabContent
    			activeTabName = tabName
    			currentTabContent = tabContent
    			currentY = tabCurrentY
    			tabBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    			api:UpdateWindowSize()
    		end
    		local enhancedTabAPI = {}
    		for key, value in pairs(tabAPI) do
    			enhancedTabAPI[key] = value
    		end
    		function enhancedTabAPI:SetVisible(visible)
    			tabBtn.Visible = visible
    			tabVisible = visible
    		end
    		function enhancedTabAPI:GetVisible()
    			return tabVisible
    		end
    		function enhancedTabAPI:SetTitle(newTitle)
    			tabName = newTitle
    			titleLabel.Text = newTitle
    		end
    		function enhancedTabAPI:GetTitle()
    			return tabName
    		end
    		function enhancedTabAPI:SetIcon(newIcon)
    			tabIcon = newIcon
    			iconLabel.Text = newIcon or ""
    			updateTitleAlignment()
    		end
    		function enhancedTabAPI:GetIcon()
    			return tabIcon
    		end
    		function enhancedTabAPI:Activate()
    			for _, content in pairs(tabContents) do
    				content.Visible = false
    			end
    			for _, btn in pairs(tabScrollFrame:GetChildren()) do
    				if btn:IsA("TextButton") then
    					btn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    				end
    			end
    			tabContent.Visible = true
    			tabBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    			activeTab = tabContent
    			activeTabName = tabName
    			currentTabContent = tabContent
    			currentY = tabCurrentY
    			api:UpdateWindowSize()
    			if tabCallback then
    				local success, errorMsg = pcall(function()
    					tabCallback(tabName, true)
    				end)
    				if not success then
    					warn("Tab callback error:", errorMsg)
    				end
    			end
    		end
    		function enhancedTabAPI:IsActive()
    			return activeTab == tabContent
    		end
    		function enhancedTabAPI:SetCallback(newCallback)
    			tabCallback = newCallback
    		end
    		return enhancedTabAPI
    	end
    	function api:SetOpacity(opacity)
    		windowOpacity = math.max(0.1, math.min(1.0, opacity))
    		local transparency = 1 - windowOpacity
    		frame.BackgroundTransparency = transparency
    		tabPanel.BackgroundTransparency = transparency
    		header.BackgroundTransparency = transparency
    	end
    	function api:GetOpacity()
    		return windowOpacity
    	end
    	function api:FadeIn(duration)
    		duration = duration or 0.3
    		local TweenService = game:GetService("TweenService")
    		local targetTransparency = 1 - windowOpacity
    		frame.BackgroundTransparency = 1
    		tabPanel.BackgroundTransparency = 1
    		header.BackgroundTransparency = 1
    		local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    		local frameTween = TweenService:Create(frame, tweenInfo, {BackgroundTransparency = targetTransparency})
    		local tabPanelTween = TweenService:Create(tabPanel, tweenInfo, {BackgroundTransparency = targetTransparency})
    		local headerTween = TweenService:Create(header, tweenInfo, {BackgroundTransparency = targetTransparency})
    		frameTween:Play()
    		tabPanelTween:Play()
    		headerTween:Play()
    	end
    	function api:FadeOut(duration)
    		duration = duration or 0.3
    		local TweenService = game:GetService("TweenService")
    		local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    		local frameTween = TweenService:Create(frame, tweenInfo, {BackgroundTransparency = 1})
    		local tabPanelTween = TweenService:Create(tabPanel, tweenInfo, {BackgroundTransparency = 1})
    		local headerTween = TweenService:Create(header, tweenInfo, {BackgroundTransparency = 1})
    		frameTween:Play()
    		tabPanelTween:Play()
    		headerTween:Play()
    	end
    	function api:Show()
    		screenGui.Enabled = true
    		floatBtn.Visible = false
    	end
    	function api:Hide()
    		screenGui.Enabled = false
    		floatBtn.Visible = true
    	end
    	function api:IsVisible()
    		return screenGui.Enabled
    	end
    	function api:ToggleVisibility()
    		screenGui.Enabled = not screenGui.Enabled
    		floatBtn.Visible = not screenGui.Enabled
    		return screenGui.Enabled
    	end
    	function api:AdaptToViewport()
    		local currentViewport = getViewportSize()
    		local baseWidth = config.Width or (currentViewport.X * 0.3)
    		local baseHeight = config.Height or (currentViewport.Y * 0.4)
    		local scaleMultiplier = 1
    		if currentViewport.X >= 1920 then 
    			scaleMultiplier = 1.2
    		elseif currentViewport.X >= 1366 then 
    			scaleMultiplier = 1.0
    		elseif currentViewport.X >= 1024 then 
    			scaleMultiplier = 0.9
    		else 
    			scaleMultiplier = 0.8
    		end
    		local newWidth = math.max(250, math.min(currentViewport.X * 0.8, baseWidth * scaleMultiplier))
    		local newHeight = math.max(150, math.min(currentViewport.Y * 0.8, baseHeight * scaleMultiplier))
    		frame.Size = UDim2.new(0, newWidth, 0, newHeight)
    		frame.Position = UDim2.new(0.5, -newWidth / 2, 0.5, -newHeight / 2)
    	end
    	function api:GetDynamicSize()
    		local currentViewport = getViewportSize()
    		return {
    			Width = frame.Size.X.Offset,
    			Height = frame.Size.Y.Offset,
    			ViewportWidth = currentViewport.X,
    			ViewportHeight = currentViewport.Y
    		}
    	end
    	function api:SetSize(width, height)
    		local viewportSize = getViewportSize()
    		width = math.max(300, math.min(width, viewportSize.X * 0.9))
    		height = math.max(200, math.min(height, viewportSize.Y * 0.9))
    		frame.Size = UDim2.new(0, width, 0, height)
    		if currentTabContent then
    			scrollFrame.CanvasSize = UDim2.new(0, 0, 0, currentY + 10)
    		end
    		return {Width = width, Height = height}
    	end
    	workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
    		if config.AutoAdapt ~= false then 
    			wait(0.1) 
    			api:AdaptToViewport()
    		end
    	end)
    	local onCloseCallback = nil
    	function api:SetCloseCallback(callback)
    		onCloseCallback = callback
    	end
    	function api:Close()
    		if onCloseCallback then
    			local success, errorMsg = pcall(function()
    				onCloseCallback()
    			end)
    			if not success then
    				warn("Close callback error:", errorMsg)
    			end
    		end
    		if screenGui then
    			screenGui:Destroy()
    		end
    	end
    	function api:SaveConfiguration()
    		if configEnabled then
    			saveConfiguration(configFileName)
    		else
    			warn("EzUI: Configuration saving is not enabled for this window")
    		end
    	end
    	function api:LoadConfiguration()
    		if configEnabled then
    			return loadConfiguration(configFileName)
    		else
    			warn("EzUI: Configuration saving is not enabled for this window")
    			return false
    		end
    	end
    	function api:GetConfigurationStatus()
    		return {
    			Enabled = configEnabled,
    			FileName = configFileName,
    			FolderName = configFolderName,
    			AutoSave = configAutoSave,
    			AutoLoad = configAutoLoad,
    			FlagsCount = #EzUI.Flags
    		}
    	end
    	function api:SetConfigValue(key, value)
    		if not key then
    			warn("EzUI: SetConfigValue requires a key parameter")
    			return false
    		end
    		EzUI.Flags[key] = value
    		if configEnabled and configAutoSave then
    			saveConfiguration(configFileName)
    		end
    		updateComponentsByFlag(key, value)
    		return true
    	end
    	function api:GetConfigValue(key, defaultValue)
    		if not key then
    			warn("EzUI: GetConfigValue requires a key parameter")
    			return defaultValue
    		end
    		local value = EzUI.Flags[key]
    		return value ~= nil and value or defaultValue
    	end
    	function api:DeleteConfigValue(key)
    		if not key then
    			warn("EzUI: DeleteConfigValue requires a key parameter")
    			return false
    		end
    		if EzUI.Flags[key] ~= nil then
    			EzUI.Flags[key] = nil
    			if configEnabled and configAutoSave then
    				saveConfiguration(configFileName)
    			end
    			return true
    		end
    		return false
    	end
    	function api:HasConfigValue(key)
    		if not key then
    			warn("EzUI: HasConfigValue requires a key parameter")
    			return false
    		end
    		return EzUI.Flags[key] ~= nil
    	end
    	function api:GetAllConfigValues()
    		local configCopy = {}
    		for key, value in pairs(EzUI.Flags) do
    			configCopy[key] = value
    		end
    		return configCopy
    	end
    	function api:ClearAllConfigValues()
    		for key in pairs(EzUI.Flags) do
    			EzUI.Flags[key] = nil
    		end
    		if configEnabled and configAutoSave then
    			saveConfiguration(configFileName)
    		end
    		return true
    	end
    	function api:SetMultipleConfigValues(keyValuePairs)
    		if type(keyValuePairs) ~= "table" then
    			warn("EzUI: SetMultipleConfigValues requires a table parameter")
    			return false
    		end
    		local updatedKeys = {}
    		for key, value in pairs(keyValuePairs) do
    			if type(key) == "string" then
    				EzUI.Flags[key] = value
    				table.insert(updatedKeys, key)
    				updateComponentsByFlag(key, value)
    			end
    		end
    		if configEnabled and configAutoSave then
    			saveConfiguration(configFileName)
    		end
    		return updatedKeys
    	end
    	closeBtn.MouseButton1Click:Connect(function()
    		api:Close()
    	end)
    	local closeConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
    		if not gameProcessed and input.KeyCode == Enum.KeyCode.Escape then
    			api:Close()
    		end
    	end)
    	local function disconnectCloseConnection()
    		if closeConnection then
    			closeConnection:Disconnect()
    			closeConnection = nil
    		end
    	end
    	local originalClose = api.Close
    	api.Close = function(self)
    		disconnectCloseConnection()
    		originalClose(self)
    	end
    	if configEnabled and configAutoLoad then
    		task.defer(function()
    			local loaded = loadConfiguration(configFileName)
    			if loaded then
    				print("EzUI: Auto-loaded configuration for " .. configFileName)
    			end
    		end)
    	end
    	return api
    end
    return EzUI
end

-- Module: CoreModule
EmbeddedModules["../module/core.lua"] = function()
    local Core = {}
    Core.Players = game:GetService("Players")
    Core.ReplicatedStorage = game:GetService("ReplicatedStorage")
    Core.TeleportService = game:GetService("TeleportService")
    Core.UserInputService = game:GetService("UserInputService")
    Core.GuiService = game:GetService("GuiService")
    Core.Workspace = game:GetService("Workspace")
    Core.VirtualUser = game:GetService("VirtualUser")
    Core.LocalPlayer = Core.Players.LocalPlayer
    Core.GameEvents = Core.ReplicatedStorage.GameEvents
    function Core:GetCharacter()
        return self.LocalPlayer.Character
    end
    function Core:GetHumanoidRootPart()
        local character = self:GetCharacter()
        return character and character:FindFirstChild("HumanoidRootPart")
    end
    function Core:GetBackpack()
        return self.LocalPlayer:FindFirstChild("Backpack")
    end
    function Core:GetPlayerGui()
        return self.LocalPlayer:FindFirstChild("PlayerGui")
    end
    return Core
end

-- Module: PlayerModule
EmbeddedModules["../module/player.lua"] = function()
    local Player = {}
    local Core
    local antiAFKConnection 
    function Player:Init(core)
        if not core then
            error("Player:Init - Core module is required")
        end
        Core = core
        antiAFKConnection = Core.LocalPlayer.Idled:Connect(function()
            Core.VirtualUser:CaptureController()
            Core.VirtualUser:ClickButton2(Vector2.new())
            print("Anti-AFK: Clicked to prevent idle kick")
        end)
    end
    function Player:RemoveAntiAFK()
        if antiAFKConnection then
            antiAFKConnection:Disconnect()
            antiAFKConnection = nil
            print("Anti-AFK: Disconnected idle connection")
        else
            print("Anti-AFK: No connection to disconnect")
        end
    end
    function Player:EquipTool(Tool)
        if not Tool or not Tool:IsA("Tool") then 
            warn("Player:EquipTool - Invalid tool provided")
            return false 
        end
        local Character = Core:GetCharacter()
        if not Character then 
            warn("Player:EquipTool - Character not found")
            return false 
        end
        local Humanoid = Character:FindFirstChild("Humanoid")
        local Backpack = Core:GetBackpack()
        if not Humanoid then
            warn("Player:EquipTool - Humanoid not found")
            return false
        end
        if not Backpack then
            warn("Player:EquipTool - Backpack not found")
            return false
        end
        if Tool.Parent ~= Backpack then 
            warn("Player:EquipTool - Tool not in backpack")
            return false 
        end
        local success, err = pcall(function()
            Humanoid:EquipTool(Tool)
        end)
        if not success then
            warn("Player:EquipTool - Failed to equip:", err)
            return false
        end
        return true
    end
    function Player:UnequipTool()
        local Character = Core:GetCharacter()
        if not Character then 
            warn("Player:UnequipTool - Character not found")
            return false 
        end
        local Humanoid = Character:FindFirstChild("Humanoid")
        if not Humanoid then
            warn("Player:UnequipTool - Humanoid not found")
            return false
        end
        local success, err = pcall(function()
            Humanoid:UnequipTools()
        end)
        if not success then
            warn("Player:UnequipTool - Failed to unequip:", err)
            return false
        end
        return true
    end
    function Player:GetEquippedTool()
        local workspace = Core.Workspace
        local player
        for _, item in ipairs(workspace:GetChildren()) do
            if item.Name == Core.LocalPlayer.Name and item:FindFirstChildOfClass("Tool") then
                player = item
                break
            end
        end
        if not player then
            warn("Player:GetEquippedTool - Player model not found in workspace")
            return nil
        end
        for _, item in ipairs(player:GetChildren()) do
            if item:IsA("Tool") then
                return item
            end
        end
        warn("Player:GetEquippedTool - No tool equipped")
        return nil
    end
    function Player:TeleportToPosition(Position)
        local HRP = Core:GetHumanoidRootPart()
        if HRP then
            HRP.CFrame = CFrame.new(Position)
            return true
        end
        return false
    end
    function Player:GetPosition()
        local HRP = Core:GetHumanoidRootPart()
        return HRP and HRP.Position or Vector3.new(0, 0, 0)
    end
    function Player:GetAllTools()
        local Backpack = Core:GetBackpack()
        if not Backpack then 
            warn("Player:GetAllTools - Backpack not found")
            return {} 
        end
        local tools = {}
        local success, err = pcall(function()
            for _, item in ipairs(Backpack:GetChildren()) do
                if item:IsA("Tool") then
                    table.insert(tools, item)
                end
            end
        end)
        if not success then
            warn("Player:GetAllTools - Error getting tools:", err)
            return {}
        end
        return tools
    end
    function Player:GetTool(toolName)
        if not toolName or type(toolName) ~= "string" then
            warn("Player:GetTool - Invalid tool name")
            return nil
        end
        local Backpack = Core:GetBackpack()
        if not Backpack then 
            warn("Player:GetTool - Backpack not found")
            return nil 
        end
        local tool = nil
        local success, err = pcall(function()
            tool = Backpack:FindFirstChild(toolName)
            if tool and not tool:IsA("Tool") then
                tool = nil
            end
        end)
        if not success then
            warn("Player:GetTool - Error finding tool:", err)
            return nil
        end
        if not tool then
            warn("Player:GetTool - Tool not found:", toolName)
        end
        return tool
    end
    return Player
end

-- Module: FarmModule
EmbeddedModules["module/farm.lua"] = function()
    local FarmUtils = {}
    local Core
    local PlayerUtils
    function FarmUtils:GetMyFarm()
    	local Farms = Core.Workspace.Farm:GetChildren()
    	for _, Farm in next, Farms do
        local Important = Farm.Important
        local Data = Important.Data
        local Owner = Data.Owner
    		if Owner.Value == Core.LocalPlayer.Name then
    			return Farm
    		end
    	end
        return
    end
    function FarmUtils:Init(core, playerUtils)
        if not core then
            error("FarmUtils:Init - Core module is required")
        end
        if not playerUtils then
            error("FarmUtils:Init - PlayerUtils module is required")
        end
        Core = core
        PlayerUtils = playerUtils
    end
    function FarmUtils:GetArea(Base: Part)
    	local Center = Base:GetPivot()
    	local Size = Base.Size
    	local X1 = math.ceil(Center.X - (Size.X/2))
    	local Z1 = math.ceil(Center.Z - (Size.Z/2))
    	local X2 = math.floor(Center.X + (Size.X/2))
    	local Z2 = math.floor(Center.Z + (Size.Z/2))
    	return X1, Z1, X2, Z2
    end
    function FarmUtils:GetFarmCenterCFrame()    
        local farm = FarmUtils:GetMyFarm()
        if not farm then
            warn("Farm not found for player:", Core.LocalPlayer.Name)
            return CFrame.new(0, 4, 0) 
        end
        local important = farm:FindFirstChild("Important")
        if not important then
            warn("Important folder not found in farm")
            return CFrame.new(0, 4, 0) 
        end
        local plantLocations = important:FindFirstChild("Plant_Locations")
        if plantLocations then
            local farmParts = plantLocations:GetChildren()
            if #farmParts > 0 then
                local totalX, totalZ = 0, 0
                local totalY = 4 
                local partCount = 0
                for _, part in pairs(farmParts) do
                    if part:IsA("BasePart") then
                        local pos = part.Position
                        totalX = totalX + pos.X
                        totalZ = totalZ + pos.Z
                        totalY = math.max(totalY, pos.Y + part.Size.Y/2) 
                        partCount = partCount + 1
                    end
                end
                if partCount > 0 then
                    local centerX = totalX / partCount
                    local centerZ = totalZ / partCount
                    return CFrame.new(centerX, totalY, centerZ)
                end
            end
        end
        local farmAreas = {"Farm_Area", "Dirt", "Farmland", "Ground"}
        for _, areaName in pairs(farmAreas) do
            local area = important:FindFirstChild(areaName, true)
            if area and area:IsA("BasePart") then
                local pos = area.Position
                return CFrame.new(pos.X, pos.Y + area.Size.Y/2 + 1, pos.Z)
            end
        end
        if farm.PrimaryPart then
            local pos = farm.PrimaryPart.Position
            return CFrame.new(pos.X, pos.Y + 4, pos.Z)
        end
        warn("Could not determine farm center for player:", Core.LocalPlayer.Name)
        return CFrame.new(0, 4, 0) 
    end
    function FarmUtils:GetRandomFarmPoint()
        local farm = FarmUtils:GetMyFarm()
        if not farm then
            return Vector3.new(0, 4, 0)
        end
        local important = farm:FindFirstChild("Important")
        if not important then
            return Vector3.new(0, 4, 0)
        end
        local plantLocations = important:FindFirstChild("Plant_Locations")
        if plantLocations then
            local farmParts = plantLocations:GetChildren()
            if #farmParts > 0 then
                local randomPart = farmParts[math.random(1, #farmParts)]
                if randomPart:IsA("BasePart") then
                    local X1, Z1, X2, Z2 = FarmUtils:GetArea(randomPart)
                    local X = math.random(X1, X2)
                    local Z = math.random(Z1, Z2)
                    return Vector3.new(X, 4, Z)
                end
            end
        end
        local centerCFrame = FarmUtils:GetFarmCenterCFrame()
        return centerCFrame and centerCFrame.Position or Vector3.new(0, 4, 0)
    end
    function FarmUtils:GetBackCornerFarmPoint()
        local farm = FarmUtils:GetMyFarm()
        if not farm then
            return Vector3.new(0, 4, 0)
        end
        local important = farm:FindFirstChild("Important")
        if not important then
            return Vector3.new(0, 4, 0)
        end
        local plantLocations = important:FindFirstChild("Plant_Locations")
        if plantLocations then
            local farmParts = plantLocations:GetChildren()
            if #farmParts > 0 then
                local randomPart = farmParts[math.random(1, #farmParts)]
                if randomPart:IsA("BasePart") then
                    local X1, Z1, X2, Z2 = FarmUtils:GetArea(randomPart)
                    return Vector3.new(X1, 4, Z2) 
                end
            end
        end
        local centerCFrame = FarmUtils:GetFarmCenterCFrame()
        return centerCFrame and centerCFrame.Position or Vector3.new(0, 4, 0)
    end
    return FarmUtils
end

-- Module: PetModule
EmbeddedModules["module/pet.lua"] = function()
    local PetUtils = {}
    local GameServices
    local PlayerUtils
    local FarmUtils
    local PetTeamConfig
    local Window
    local AutoHatchConnection
    local isHatchingInProgress = false
    function PetUtils:Init(gameServices, playerUtils, farmUtils, petTeamConfig, window)
        GameServices = gameServices
        PlayerUtils = playerUtils
        FarmUtils = farmUtils
        PetTeamConfig = petTeamConfig
        Window = window
        local iSEnabledAutoHatch = Window:GetConfigValue("AutoHatchEggs") or false
        local EggReadyToHatchRemote = gameServices.GameEvents.EggReadyToHatch_RE
        AutoHatchConnection = EggReadyToHatchRemote.OnClientEvent:Connect(function(petName, eggUUID)
            if not iSEnabledAutoHatch then
                return
            end
            self:QueueHatchRequest()
        end)
        if not iSEnabledAutoHatch then
            return
        end
        self:QueueHatchRequest()
    end
    function PetUtils:RemoveAutoHatchConnection()
        if AutoHatchConnection then
            AutoHatchConnection:Disconnect()
        end
    end
    function PetUtils:QueueHatchRequest()
        if isHatchingInProgress then
            print("Hatching already in progress, waiting...")
            return
        end
        isHatchingInProgress = true
        self:HatchEgg()
        wait(1)
        isHatchingInProgress = false
    end
    function PetUtils:GetPetReplicationData()
        local ReplicationClass = require(GameServices.ReplicatedStorage.Modules.ReplicationClass)
        local ActivePetsReplicator = ReplicationClass.new("ActivePetsService_Replicator")
        return ActivePetsReplicator:YieldUntilData().Table
    end
    function PetUtils:GetPlayerPetData()
        local success, replicationData = pcall(self.GetPetReplicationData, self)
        if not success then
            warn("Failed to get replication data:", replicationData)
            return nil
        end
        local playerPetData = replicationData.PlayerPetData
        local playerData = playerPetData[GameServices.LocalPlayer.Name] or playerPetData[tonumber(GameServices.LocalPlayer.Name)]
        return playerData
    end
    function PetUtils:GetPetData(petUUID)
        local playerData = self:GetPlayerPetData()
        if playerData and playerData.PetInventory then
            return playerData.PetInventory.Data[petUUID]
        end
        return nil
    end
    function PetUtils:GetAllActivePets()
        local success, replicationData = pcall(function()
            return self:GetPetReplicationData()
        end)
        if not success then
            warn("Failed to get replication data:", replicationData)
            return nil
        end
        local activePetStates = replicationData.ActivePetStates
        local playerPets = activePetStates[GameServices.LocalPlayer.Name] or activePetStates[tonumber(playerName)]
        return playerPets
    end
    function PetUtils:BoostPet(petID)
        GameServices.GameEvents.PetBoostService:FireServer(
            "ApplyBoost",
            petID
        )
    end
    function PetUtils:BoostAllActivePets()
        local activePets = self:GetAllActivePets()
        if not activePets then
            print("No active pets found to boost.")
            return
        end
        local boostTool = {}
        for _, Tool in next, PlayerUtils:GetAllTools() do
            local toolType = Tool:GetAttribute("q")
            if toolType == "PASSIVE_BOOST" then
                table.insert(boostTool, Tool)
            end
        end
        if #boostTool == 0 then
            print("No boost tool found in inventory.")
            return
        end
        for _, Tool in next, boostTool do
            PlayerUtils:EquipTool(Tool)
            wait(0.5)
            for petUUID, _ in pairs(activePets) do
                self:BoostPet(petUUID)
                wait(1) 
            end
        end
        PlayerUtils:UnequipTool()
    end
    function PetUtils:EquipPet(PetID)
        GameServices.GameEvents.PetsService:FireServer(
            "EquipPet",
            PetID,
            FarmUtils:GetFarmCenterCFrame()
        )
    end
    function PetUtils:UnequipPet(PetID)
        GameServices.GameEvents.PetsService:FireServer(
            "UnequipPet",
            PetID
        )
    end
    function PetUtils:SaveTeamPets(teamName)
        local activePets = self:GetAllActivePets()
        if not activePets then
            print("No active pets found.")
            return
        end
        local listActivePets = {}
        for petUUID, petState in pairs(activePets) do
            table.insert(listActivePets, petUUID)
        end
        PetTeamConfig.SetValue(teamName, listActivePets)
    end
    function PetUtils:GetAllPetTeams()
        return PetTeamConfig.GetAllKeys()
    end
    function PetUtils:FindPetTeam(teamName)
        return PetTeamConfig.GetValue(teamName)
    end
    function PetUtils:DeleteTeamPets(teamName)
        PetTeamConfig.DeleteKey(teamName)
    end
    function PetUtils:ChangeToTeamPets(teamName)
        local petsInTeam = PetTeamConfig.GetValue(teamName)
        if not petsInTeam then
            print("No pets found in the team:", teamName)
            return
        end
        local activePets = self:GetAllActivePets(GameServices.LocalPlayer.Name)
        if activePets then
            for petUUID, _ in pairs(activePets) do
                self:UnequipPet(petUUID)
            end
        end
        for _, petUUID in pairs(petsInTeam) do
            self:EquipPet(petUUID)
        end
    end
    function PetUtils:GetAllOwnedPets()
        local myPets = {}
        for _, Tool in next, PlayerUtils:GetAllTools() do
            local toolType = Tool:GetAttribute("b")
            toolType = toolType and string.lower(toolType) or ""
            if toolType == "l" then
                table.insert(myPets, {text = Tool.Name, value = Tool.Name})
            end
        end
        if #myPets > 0 then
            table.sort(myPets, function(a, b)
                if not a or not b or not a.text or not b.text then
                    return false
                end
                return string.lower(tostring(a.text)) < string.lower(tostring(b.text))
            end)
        end
        return myPets
    end
    function PetUtils:GetPetDetail(petUUID)
        local success, result = pcall(function()
            local dataService = require(GameServices.ReplicatedStorage.Modules.DataService)
            local allData = dataService:GetData()
            if not allData then
                warn("No data available from DataService")
                return nil
            end
            local saveSlots = allData.SaveSlots
            if not saveSlots then
                warn("SaveSlots not found in data")
                return nil
            end
            local savedObjects = saveSlots.AllSlots[saveSlots.SelectedSlot].SavedObjects
            if savedObjects and petUUID and savedObjects[petUUID] then
                return savedObjects[petUUID].Data
            end
            warn("Falling back to ReplicationClass method")
            local ReplicationClass = require(GameServices.ReplicatedStorage.Modules.ReplicationClass)
            local DataStreamReplicator = ReplicationClass.new("DataStreamReplicator")
            DataStreamReplicator:YieldUntilData()
            local replicationData = DataStreamReplicator:YieldUntilData().Table
            local playerData = replicationData[GameServices.LocalPlayer.Name] or replicationData[tostring(GameServices.LocalPlayer.UserId)]
            if playerData and playerData[petUUID] then
                return playerData[petUUID].Data
            end
            return nil
        end)
        if success then
            return result
        else
            warn("Failed to get pet data:", result)
            return nil
        end
    end
    function PetUtils:GetPetRegistry()
        local success, petRegistry = pcall(function()
            return require(GameServices.ReplicatedStorage.Data.PetRegistry)
        end)
        if success then           
            local petList = petRegistry.PetList
            if petList then
                local formattedPets = {}
                for petName, petData in pairs(petList) do
                    table.insert(formattedPets, {
                        text = petName,
                        value = petName
                    })
                end
                if #formattedPets > 0 then
                    table.sort(formattedPets, function(a, b)
                        if not a or not b or not a.text or not b.text then
                            return false
                        end
                        return string.lower(tostring(a.text)) < string.lower(tostring(b.text))
                    end)
                end
                return formattedPets
            else
                warn("PetUtils:GetPetRegistry - PetList is nil or not found")
                return {}
            end
        else
            warn("Failed to get pet registry:", petRegistry)
            return {}
        end
    end
    function PetUtils:SellPet()
        local petName = Window:GetConfigValue("PetToSell") or {}
        local weighLessThan = Window:GetConfigValue("WeightThresholdSellPet") or 1
        local ageLessThan = Window:GetConfigValue("AgeThresholdSellPet") or 1
        local sellPetTeam = Window:GetConfigValue("SellPetTeam") or nil
        local boostBeforeSelling = Window:GetConfigValue("AutoBoostBeforeSelling") or false
        local corePetTeam = Window:GetConfigValue("CorePetTeam") or nil
        if #petName == 0 then
            print("No pet selected for selling.")
            return
        end
        if sellPetTeam then
            self:ChangeToTeamPets(sellPetTeam)
            wait(2)
        end
        if boostBeforeSelling then
            wait(2)
            PlayerUtils:UnequipTool()
            self:BoostAllActivePets()
        end
        for _, Tool in next, PlayerUtils:GetAllTools() do
            local toolType = Tool:GetAttribute("b")
            local petUUID = Tool:GetAttribute("PET_UUID")
            local isFavorite = Tool:GetAttribute("d") or false
            if not isFavorite and toolType == "l" and petUUID then
                local petData = self:GetPetData(petUUID)
                if petData then
                    local petDetail = petData.PetData
                    local petType = petData.PetType or "Unknown"
                    local petWeight = petDetail.BaseWeight or 0
                    local petAge = petDetail.Level or math.huge
                    for _, selectedPet in ipairs(petName) do
                        if petType == selectedPet 
                            and petWeight <= weighLessThan
                            and petAge <= ageLessThan then
                            PlayerUtils:EquipTool(Tool)
                            wait(0.5)
                            local getEquippedTool = PlayerUtils:GetEquippedTool()
                            GameServices.GameEvents.SellPet_RE:FireServer(getEquippedTool)
                            wait(0.5)
                        end
                    end
                end
            end
        end
        if corePetTeam then
            wait(2)
            print("Reverting to Core Pet Team:", corePetTeam)
            self:ChangeToTeamPets(corePetTeam)
            wait(2)
        end
    end
    function PetUtils:GetAllOwnedEggs()
        local myEggs = {}
        for _, Tool in next, PlayerUtils:GetAllTools() do
            local toolType = Tool:GetAttribute("b")
            toolType = toolType and string.lower(toolType) or ""
            if toolType == "c" then
                table.insert(myEggs, {text = Tool.Name, value = Tool:GetAttribute("h")})
            end
        end
        if #myEggs > 0 then
            table.sort(myEggs, function(a, b)
                if not a or not b or not a.text or not b.text then
                    return false
                end
                return string.lower(tostring(a.text)) < string.lower(tostring(b.text))
            end)
        end
        return myEggs
    end
    function PetUtils:FindEggOwnedEgg(eggName)
        for _, Tool in next, PlayerUtils:GetAllTools() do
            local toolType = Tool:GetAttribute("b")
            local toolName = Tool:GetAttribute("h")
            toolType = toolType and string.lower(toolType) or ""
            toolName = toolName and string.lower(toolName) or ""
            if toolType == "c" and toolName == string.lower(eggName) then
                return Tool
            end
        end
        return nil
    end
    function PetUtils:GetPlacedEggDetail(eggUUID)
        local success, result = pcall(function()
            local dataService = require(GameServices.ReplicatedStorage.Modules.DataService)
            local allData = dataService:GetData()
            if not allData then
                warn("No data available from DataService")
                return nil
            end
            local saveSlots = allData.SaveSlots
            if not saveSlots then
                warn("SaveSlots not found in data")
                return nil
            end
            local savedObjects = saveSlots.AllSlots[saveSlots.SelectedSlot].SavedObjects
            if savedObjects and eggUUID and savedObjects[eggUUID] then
                return savedObjects[eggUUID].Data
            end
            warn("Falling back to ReplicationClass method")
            local ReplicationClass = require(GameServices.ReplicatedStorage.Modules.ReplicationClass)
            local DataStreamReplicator = ReplicationClass.new("DataStreamReplicator")
            DataStreamReplicator:YieldUntilData()
            local replicationData = DataStreamReplicator:YieldUntilData().Table
            local playerData = replicationData[GameServices.LocalPlayer.Name] or replicationData[tostring(GameServices.LocalPlayer.UserId)]
            if playerData and playerData[eggUUID] then
                return playerData[eggUUID].Data
            end
            return nil
        end)
        if success then
            return result
        else
            warn("Failed to get egg data:", result)
            return nil
        end
    end
    function PetUtils:GetAllPlacedEggs()
        local placedEggs = {}
        local MyFarm = FarmUtils:GetMyFarm()
        if not MyFarm then
            warn("My farm not found!")
            return placedEggs
        end
        local objectsPhysical = MyFarm.Important.Objects_Physical
        if not objectsPhysical then
            warn("Objects_Physical not found!")
            return placedEggs
        end
        for _, egg in pairs(objectsPhysical:GetChildren()) do
            pcall(function()
                if egg.Name == "PetEgg" then
                    local owner = egg:GetAttribute("OWNER")
                    if owner == GameServices.LocalPlayer.Name then
                        table.insert(placedEggs, egg)
                    end
                end
            end)
        end
        return placedEggs
    end
    function PetUtils:HatchEgg()
        print("Hatching eggs...")
        local placedEggs = self:GetAllPlacedEggs()
        if #placedEggs == 0 then
            print("No placed eggs found to hatch.")
            return
        end
        wait(2)
        local maxTimeToHatch = 0
        local eggsToHatch = {}
        for _, egg in pairs(placedEggs) do
            if egg.Name == "PetEgg" then
                local owner = egg:GetAttribute("OWNER")
                local timeToHatch = egg:GetAttribute("TimeToHatch") or 0
                if owner == GameServices.LocalPlayer.Name then
                    if timeToHatch > 0 then
                        maxTimeToHatch = math.max(maxTimeToHatch, timeToHatch)
                    end
                    table.insert(eggsToHatch, egg)
                end
            end
        end
        local waitTime = math.max(2, maxTimeToHatch)
        wait(waitTime)
        if #eggsToHatch == 0 then
            print("No eggs are ready to hatch.")
            return
        end
        local hatchPetTeam = Window:GetConfigValue("HatchPetTeam") or nil
        local specialHatchPetTeam = Window:GetConfigValue("SpecialHatchPetTeam") or nil
        local specialHatchingPets = Window:GetConfigValue("SpecialHatchingPet") or {}
        local weightThresholdSpecialHatching = Window:GetConfigValue("WeightThresholdSpecialHatching") or math.huge
        local boostBeforeHatch = Window:GetConfigValue("AutoBoostBeforeHatch") or false
        if hatchPetTeam then
            self:ChangeToTeamPets(hatchPetTeam)
            wait(2)
            if boostBeforeHatch then
                self:BoostAllActivePets()
            end
        end
        local specialHatchingEgg = {}
        for _, egg in pairs(eggsToHatch) do
            local eggUUID = egg:GetAttribute("OBJECT_UUID")
            local eggData = self:GetPlacedEggDetail(eggUUID)
            local baseWeight = eggData and eggData.BaseWeight or 1
            local petName = eggData and eggData.Type or "Unknown"
            local isSpecialPet = false
            for _, specialPet in ipairs(specialHatchingPets) do
                if petName == specialPet then
                    table.insert(specialHatchingEgg, egg)
                    isSpecialPet = true
                    break
                end
            end
            if not isSpecialPet then
                if baseWeight > weightThresholdSpecialHatching then
                    table.insert(specialHatchingEgg, egg)
                else
                    GameServices.GameEvents.PetEggService:FireServer("HatchPet", egg)
                end
            end
        end
        if specialHatchPetTeam and #specialHatchingEgg > 0 then
            self:ChangeToTeamPets(specialHatchPetTeam)
            wait(2)
        end
        print("Hatching special eggs separately to avoid server spam.")
        for _, egg in pairs(specialHatchingEgg) do
            local eggUUID = egg:GetAttribute("OBJECT_UUID")
            local eggData = self:GetPlacedEggDetail(eggUUID)
            local baseWeight = eggData and eggData.BaseWeight or 1
            local petName = eggData and eggData.Type or "Unknown"
            print("Hatching special Pet:", petName, "Weight:", baseWeight)
            GameServices.GameEvents.PetEggService:FireServer("HatchPet", egg)
        end
        local isAutoSellAfterHatch = Window:GetConfigValue("AutoSellPetsAfterHatching") or false
        local corePetTeam = Window:GetConfigValue("CorePetTeam") or nil
        if isAutoSellAfterHatch then
            wait(10)
            self:SellPet()
        elseif corePetTeam then
            self:ChangeToTeamPets(corePetTeam)
        end
        self:PlaceEgg()
    end
        local isAutoSellAfterHatch = Window:GetConfigValue("AutoSellPetsAfterHatching") or false
        local corePetTeam = Window:GetConfigValue("CorePetTeam") or nil
        if isAutoSellAfterHatch then
            wait(10) 
            self:SellPet()
        else
            self:ChangeToTeamPets(corePetTeam)
        end
        self:PlaceEgg()
    end
    function PetUtils:PlaceEgg()
        local eggName = Window:GetConfigValue("EggPlacing") or ""
        local maxEggs = Window:GetConfigValue("MaxPlaceEggs") or 0
        if eggName == "" then
            return
        end
        local totalPlacedEggs = #self:GetAllPlacedEggs()
        local availableSlots = maxEggs - totalPlacedEggs
        if availableSlots < 1 then
            return
        end
        local eggOwnedName = self:FindEggOwnedEgg(eggName)
        if not eggOwnedName then
            return
        end
        PlayerUtils:EquipTool(eggOwnedName)
        wait(0.5) 
        for i = 1, availableSlots do
            local success = pcall(function()
                local randomPoint = FarmUtils:GetRandomFarmPoint()
                if randomPoint then
                    GameServices.GameEvents.PetEggService:FireServer("CreateEgg", randomPoint)
                end
            end)
            if not success then
                warn("Failed to place egg", i)
            end
            wait(0.5)
        end
        PlayerUtils:UnequipTool() 
    end
    return PetUtils
end

-- Module: PetModule
EmbeddedModules["ui/pet.lua"] = function()
    local UIPet = {}
    local window
    local PetUtils
    local FarmUtils
    function UIPet:Init(windowInstance, petUtils, farmUtils)
        window = windowInstance
        PetUtils = petUtils
        FarmUtils = farmUtils
    end
    function UIPet:CreatePetTab()
        local petTab = window:AddTab({
            Name = "Pets",
            Icon = "🐾",
        })
        self:CreatePetTeamsSection(petTab)
        self:CreateEggsSection(petTab)
    end
    function UIPet:CreatePetTeamsSection(petTab)
        local accordionPetTeams = petTab:AddAccordion({
            Title = "Pet Teams",
            Icon = "💪",
            Expanded = false,
        })
        accordionPetTeams:AddLabel("Create and manage pet teams for different tasks.")
        local petTeamName = accordionPetTeams:AddTextBox({
            Name = "Team Name",
            Placeholder = "Enter team name example: exp, hatch, sell, etc...",
            Default = "",
        })
        accordionPetTeams:AddButton("Save Team", function()
            local teamName = petTeamName.GetText()
            if teamName and teamName ~= "" then
                print("Creating pet team:", teamName)
                PetUtils:SaveTeamPets(teamName)
                petTeamName.Clear()
            else
                print("Please enter a valid team name.")
            end
        end)
        accordionPetTeams:AddSeparator()
        accordionPetTeams:AddLabel("Select a pet team to set as core, change, or delete.")
        local selectTeam = accordionPetTeams:AddSelectBox({
            Name = "Select Pet Team",
            Options = PetUtils:GetAllPetTeams(),
            Placeholder = "Select Pet Team...",
            MultiSelect = false,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local listTeamPet = PetUtils:GetAllPetTeams()
                local currentOptionsSet = {}
                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                updateOptions(currentOptionsSet)
            end
        })
        local labelCoreTeam
        accordionPetTeams:AddButton("Set Core Team", function()
            local selectedTeam = selectTeam.GetSelected()
            if selectedTeam and #selectedTeam > 0 then
                local teamName = selectedTeam[1]
                window:SetConfigValue("CorePetTeam", teamName)
                labelCoreTeam.SetText("Current Core Team: " .. teamName)
            end    
        end)
        labelCoreTeam = accordionPetTeams:AddLabel("Current Core Team: " .. (window:GetConfigValue("CorePetTeam") or "None"))
        accordionPetTeams:AddSeparator()
        accordionPetTeams:AddButton("Change Team", function()
            local selectedTeam = selectTeam.GetSelected()
            if selectedTeam and #selectedTeam > 0 then
                local teamName = selectedTeam[1]
                local petsInTeam = PetUtils:FindPetTeam(teamName)
                if petsInTeam then
                    print("Changing to pet team:", teamName)
                    local activePets = PetUtils:GetAllActivePets()
                    if activePets then
                        for petUUID, _ in pairs(activePets) do
                            print("Deactivating Active Pet:", petUUID)
                            PetUtils:UnequipPet(petUUID)
                        end
                    end
                    for _, petUUID in pairs(petsInTeam) do
                        print("Activating Pet from Team:", petUUID)
                        PetUtils:EquipPet(petUUID)
                    end
                else
                    print("No pets found in the selected team.")
                end
            else
                print("Please select a team to change to.")
            end    
        end)
        accordionPetTeams:AddButton("Delete Selected Team", function()
            local selectedTeam = selectTeam.GetSelected()
            if selectedTeam and #selectedTeam > 0 then
                local teamName = selectedTeam[1]
                PetUtils:DeleteTeamPets(teamName)
                selectTeam.Clear()
            else
                print("Please select a team to delete.")
            end
        end)
    end
    function UIPet:CreateEggsSection(petTab)
        local accordionEggs = petTab:AddAccordion({
            Title = "Eggs",
            Icon = "🥚",
            Expanded = false,
        })
        accordionEggs:AddLabel("Select an egg to place in your farm.")
        local eggSelect = accordionEggs:AddSelectBox({
            Name = "Select Egg",
            Options = {"Loading..."},
            Placeholder = "Select Egg...",
            MultiSelect = false,
            Flag = "EggPlacing",
            OnInit = function(currentOptions, updateOptions, selectBoxAPI)
                local OwnedEggs = PetUtils:GetAllOwnedEggs()
                updateOptions(OwnedEggs)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local currentOptionsSet = {}
                local OwnedEggs = PetUtils:GetAllOwnedEggs()
                print("Owned Eggs Found:")
                for _, egg in pairs(OwnedEggs) do
                    print("Found owned egg:", egg.text)
                    table.insert(currentOptionsSet, {text = egg.text, value = egg.value})
                end
                updateOptions(currentOptionsSet)
            end
        })
        accordionEggs:AddLabel("Max Place Eggs")
        local maxPlaceEggs = accordionEggs:AddNumberBox({
            Name = "Max Place Eggs",
            Placeholder = "Enter max eggs...",
            Default = 0,
            Min = 0,
            Max = 13,
            Increment = 1,
            Flag = "MaxPlaceEggs",
        })
        accordionEggs:AddButton("Place Selected Egg", function()
            PetUtils:PlaceEgg()    
        end)
        accordionEggs:AddSeparator()
        accordionEggs:AddLabel("Team for Hatching Eggs")
        local selectTeamForHatch = accordionEggs:AddSelectBox({
            Name = "Select Pet Team for Hatch",
            Options = {"Loading..."},
            Placeholder = "Select Pet Team...",
            MultiSelect = false,
            Flag = "HatchPetTeam",
            OnInit = function(currentOptions, updateOptions)
                local listTeamPet = PetUtils:GetAllPetTeams()
                local currentOptionsSet = {}
                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                updateOptions(currentOptionsSet)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local listTeamPet = PetUtils:GetAllPetTeams()
                local currentOptionsSet = {}
                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                updateOptions(currentOptionsSet)
            end
        })
        accordionEggs:AddToggle({
            Name = "Auto Boost Pets Before Hatching",
            Default = false,
            Flag = "AutoBoostBeforeHatch",
        })
        accordionEggs:AddSeparator()
        accordionEggs:AddLabel("Select Hatching Special Pet")
        local selectSpecialPet = accordionEggs:AddSelectBox({
            Name = "Select Special Pet",
            Options = {"Loading..."},
            Placeholder = "Select Special Pet...",
            MultiSelect = true,
            Flag = "SpecialHatchingPet",
            OnInit = function(currentOptions, updateOptions, selectBoxAPI)
                local specialPets = PetUtils:GetPetRegistry()
                updateOptions(specialPets)
            end
        })
        accordionEggs:AddLabel("Or If Weight is Higher Than")
        local weightThresholdSpecialHatchingInput = accordionEggs:AddNumberBox({
            Name = "Weight Threshold",
            Placeholder = "Enter weight...",
            Default = 0.0,
            Min = 0.0,
            Max = 20.0,
            Increment = 1.0,
            Decimals = 2,
            Flag = "WeightThresholdSpecialHatching",
        })
        accordionEggs:AddLabel("Select Team for Special Hatching")
        local selectTeamForSpecialHatch = accordionEggs:AddSelectBox({
            Name = "Select Pet Team for Special Hatch",
            Options = {"Loading..."},
            Placeholder = "Select Pet Team...",
            MultiSelect = false,
            Flag = "SpecialHatchPetTeam",
            OnInit = function(currentOptions, updateOptions)
                local listTeamPet = PetUtils:GetAllPetTeams()
                local currentOptionsSet = {}
                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                updateOptions(currentOptionsSet)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local listTeamPet = PetUtils:GetAllPetTeams()
                local currentOptionsSet = {}
                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                updateOptions(currentOptionsSet)
            end
        })
        accordionEggs:AddToggle({
            Name = "Auto Boost Pets Before Special Hatching",
            Default = false,
            Flag = "AutoBoostBeforeSpecialHatch",
        })
        accordionEggs:AddSeparator()
        local toggleOnlyHatchWhenReady = accordionEggs:AddToggle({
            Name = "Only Hatch When Ready",
            Default = true,
            Flag = "OnlyHatchWhenReady",
        })
        local toggleAutoHatch = accordionEggs:AddToggle({
            Name = "Auto Hatch Eggs",
            Default = false,
            Flag = "AutoHatchEggs",
        })
        accordionEggs:AddButton("Hatch All Ready Eggs", function()
            PetUtils:HatchEgg()
        end)
        local accordionSellPets = petTab:AddAccordion({
            Title = "Sell Pets",
            Icon = "💰",
            Expanded = false,
        })
        accordionSellPets:AddLabel("Select a pet to sell.")
        local selectPetToSell = accordionSellPets:AddSelectBox({
            Name = "Select Pet to Sell",
            Options = {"Loading..."},
            Placeholder = "Select Pet...",
            MultiSelect = true,
            Flag = "PetToSell",
            OnInit = function(currentOptions, updateOptions, selectBoxAPI)
                local specialPets = PetUtils:GetPetRegistry()
                updateOptions(specialPets)
            end,
        })
        accordionSellPets:AddLabel("And If Base Weight Is Less Than Or Equal")
        local weightThresholdSellPet = accordionSellPets:AddNumberBox({
            Name = "Weight Threshold",
            Placeholder = "Enter weight...",
            Default = 1.0,
            Min = 0.5,
            Max = 20.0,
            Increment = 1.0,
            Decimals = 2,
            Flag = "WeightThresholdSellPet",
        })
        accordionSellPets:AddLabel("And If Age Is Less Than Or Equal")
        local ageThresholdSellPet = accordionSellPets:AddNumberBox({
            Name = "Age Threshold (in days)",
            Placeholder = "Enter age...",
            Default = 1,
            Min = 1,
            Max = 100,
            Increment = 1,
            Flag = "AgeThresholdSellPet",
        })
        accordionSellPets:AddLabel("Pet Team to Use for Selling")
        local selectTeamForSell = accordionSellPets:AddSelectBox({
            Name = "Select Pet Team for Sell",
            Options = {"Loading..."},
            Placeholder = "Select Pet Team...",
            MultiSelect = false,
            Flag = "SellPetTeam",
            OnInit = function(currentOptions, updateOptions)
                local listTeamPet = PetUtils:GetAllPetTeams()
                local currentOptionsSet = {}
                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                updateOptions(currentOptionsSet)
            end,
            OnDropdownOpen = function(currentOptions, updateOptions)
                local listTeamPet = PetUtils:GetAllPetTeams()
                local currentOptionsSet = {}
                for _, team in pairs(listTeamPet) do
                    table.insert(currentOptionsSet, {text = team, value = team})
                end
                updateOptions(currentOptionsSet)
            end
        })
        accordionSellPets:AddToggle({
            Name = "Auto Boost Pets Before Selling",
            Default = false,
            Flag = "AutoBoostBeforeSelling",
        })
        accordionSellPets:AddToggle({
            Name = "Auto Sell Pets After Hatching",
            Default = false,
            Flag = "AutoSellPetsAfterHatching",
        })
        accordionSellPets:AddButton("Sell Selected Pet", function()
            PetUtils:SellPet()
        end)
    end
    return UIPet
end

-- 🔧 EMBEDDED MODULE LOADER
local function loadModule(url)
    if EmbeddedModules[url] then
        return EmbeddedModules[url]()
    end
    
    error("Module not found in bundle: " .. tostring(url))
end

-- 🚀 MAIN SCRIPT
local EzUI = loadModule('https://raw.githubusercontent.com/alfin-efendy/ez-rbx-ui/refs/heads/main/ui.lua')
local Core = loadModule('../module/core.lua')
local PlayerUtils = loadModule('../module/player.lua')
local FarmUtils = loadModule('module/farm.lua')
local PetUtils = loadModule('module/pet.lua')
local PetUI = loadModule('ui/pet.lua')
local window = EzUI.CreateWindow({
    Name = "EzGarden",
    Width = 700,
    Height = 400,
    Opacity = 0.9,
    AutoAdapt = true,
    AutoShow = false,
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "EzGarden",
        FileName = "settings",
        AutoLoad = true,
        AutoSave = true,
    },
})
window:SetCloseCallback(function()
	print("Window is closing! Performing cleanup...")
    PlayerUtils:RemoveAntiAFK()
    PetUtils:RemoveAutoHatchConnection()
	print("Cleanup completed!")
end)
PlayerUtils:Init(Core)
FarmUtils:Init(Core, PlayerUtils)
PetUtils:Init(Core, PlayerUtils, FarmUtils, EzUI.NewConfig("PetTeamConfig"), window)
PetUI:Init(window, PetUtils, FarmUtils)
PetUI:CreatePetTab()