#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const https = require('https');

class RobloxBundler {
    constructor() {
        this.modules = new Map();
        this.bundledCode = '';
    }

    // Extract GitHub URLs from loadstring calls
    extractGitHubUrls(code) {
        const regex = /loadstring\(game:HttpGet\('([^']+)'\)\)\(\)/g;
        const urls = [];
        let match;
        
        while ((match = regex.exec(code)) !== null) {
            urls.push(match[1]);
        }
        
        return urls;
    }

    // Convert GitHub URL to local module name
    urlToModuleName(url) {
        const parts = url.split('/');
        const filename = parts[parts.length - 1].replace('.lua', '');
        return filename.charAt(0).toUpperCase() + filename.slice(1) + 'Module';
    }

    // Check if URL is from our rbx-script-dev repository
    isLocalRepoUrl(url) {
        return url.includes('alfin-efendy/rbx-script-dev');
    }

    // Download module from GitHub with caching
    async downloadModule(url, isLocalOnly = false) {
        const moduleName = this.urlToModuleName(url);
        
        // Check if it's from our local repository
        if (this.isLocalRepoUrl(url) && isLocalOnly) {
            // Try to load from local file first
            const baseRepoUrl = 'https://raw.githubusercontent.com/alfin-efendy/rbx-script-dev/refs/heads/main/';
            if (url.startsWith(baseRepoUrl)) {
                const relativePath = url.replace(baseRepoUrl, '');
                const localFilePath = path.join(__dirname, '..', relativePath);
                
                if (fs.existsSync(localFilePath)) {
                    const content = fs.readFileSync(localFilePath, 'utf8');
                    console.log(`‚úÖ Loaded ${relativePath} from LOCAL`);
                    return { name: moduleName, code: content };
                }
            }
        }
        
        // External URL not allowed in local-only mode
        if (isLocalOnly) {
            console.log(`‚ùå External URL not allowed in local-only mode: ${url}`);
            throw new Error(`External URL not allowed in local-only mode: ${url}`);
        }

        // Download from GitHub
        return new Promise((resolve, reject) => {
            https.get(url, (res) => {
                let data = '';
                
                res.on('data', (chunk) => {
                    data += chunk;
                });
                
                res.on('end', () => {
                    console.log(`‚úÖ Downloaded ${moduleName} from GitHub`);
                    resolve({ name: moduleName, code: data });
                });
            }).on('error', (err) => {
                console.error(`‚ùå Failed to download ${url}:`, err.message);
                reject(err);
            });
        });
    }

    // Bundle the main script with all dependencies
    async bundle(filePath, outputPath, options = {}) {
        const { localOnly = false, githubOnly = false } = options;
        
        if (localOnly) {
            console.log('üîß LOCAL-ONLY MODE: Will only use local files');
        } else if (githubOnly) {
            console.log('üåê GITHUB-ONLY MODE: Will download all modules from GitHub');
        } else {
            console.log('üîÑ HYBRID MODE: Will try local first, then GitHub');
        }

        console.log('üöÄ Starting Roblox Script Bundler...');
        
        // Read main script
        const mainScript = fs.readFileSync(filePath, 'utf8');
        console.log(`üìñ Read main script: ${filePath}`);
        
        // Extract all external module URLs
        const urls = this.extractGitHubUrls(mainScript);
        console.log(`üîç Found ${urls.length} external modules`);
        
        // Download all modules
        const modules = [];
        for (const url of urls) {
            const moduleName = this.urlToModuleName(url);
            console.log(`‚¨áÔ∏è  Downloading ${moduleName}...`);
            
            try {
                const module = await this.downloadModule(url, localOnly);
                modules.push({ url, ...module });
            } catch (error) {
                console.log(`‚ùå Failed to load ${moduleName}`);
                if (localOnly) {
                    // In local-only mode, continue without this module
                    continue;
                } else {
                    throw error;
                }
            }
        }
        
        // Generate bundled script
        let bundled = `-- üì¶ BUNDLED ROBLOX SCRIPT
-- Generated by RobloxBundler
-- Date: ${new Date().toISOString()}

-- üìö EMBEDDED MODULES
local EmbeddedModules = {}

`;

        // Add embedded modules
        for (const module of modules) {
            bundled += `-- Module: ${module.name}
EmbeddedModules["${module.url}"] = function()
${module.code.split('\n').map(line => '    ' + line).join('\n')}
end

`;
        }

        // Add simple loader function
        bundled += `-- üîß SMART MODULE LOADER
local function loadModule(url)
    -- Try embedded module first
    if EmbeddedModules[url] then
        return EmbeddedModules[url]()
    end
    
    -- Fallback to original loadstring
    print("üåê [GITHUB] Loading from:", url)
    return loadstring(game:HttpGet(url))()
end

-- üöÄ MAIN SCRIPT
`;
        
        // Replace loadstring calls in main script 
        let modifiedMain = mainScript;
        for (const url of urls) {
            const originalCall = `loadstring(game:HttpGet('${url}'))()`;
            const newCall = `loadModule('${url}')`;
            modifiedMain = modifiedMain.replace(originalCall, newCall);
        }
        
        bundled += modifiedMain;
        
        // Write bundled script
        fs.writeFileSync(outputPath, bundled);
        console.log(`‚úÖ Bundle created: ${outputPath}`);
        console.log(`üìä Stats:`);
        console.log(`  - Modules bundled: ${modules.length}`);
        console.log(`  - Output size: ${(bundled.length / 1024).toFixed(2)} KB`);
        
        return bundled;
    }
}

// CLI handling
if (require.main === module) {
    const args = process.argv.slice(2);
    
    if (args.length < 2) {
        console.log('Usage: node bundler.js <input.lua> <output.lua> [--local-only|--github-only|--hybrid]');
        process.exit(1);
    }
    
    const inputPath = path.resolve(args[0]);
    const outputPath = path.resolve(args[1]);
    
    const options = {};
    if (args.includes('--local-only')) {
        options.localOnly = true;
    } else if (args.includes('--github-only')) {
        options.githubOnly = true;
    }
    
    const bundler = new RobloxBundler();
    bundler.bundle(inputPath, outputPath, options)
        .then(() => {
            console.log('üéâ Bundling completed successfully!');
        })
        .catch((error) => {
            console.error('‚ùå Bundling failed:', error.message);
            process.exit(1);
        });
}

module.exports = RobloxBundler;